// Code generated by "goki generate"; DO NOT EDIT.

package gi

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

// MenuBarType is the [gti.Type] for [MenuBar]
var MenuBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.MenuBar",
	ShortName:  "gi.MenuBar",
	IDName:     "menu-bar",
	Doc:        "MenuBar is a Layout (typically LayoutHoriz) that renders a gradient\nbackground and has convenience methods for adding menus.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MainMenu", &gti.Field{Name: "MainMenu", Type: "bool", Doc: "is this the main menu bar for a window?  controls whether displayed on macOS", Directives: gti.Directives{}}},
		{"OSMainMenus", &gti.Field{Name: "OSMainMenus", Type: "map[string]*Button", Doc: "map of main menu items for callback from OS main menu (MacOS specific)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MenuBar{},
})

// NewMenuBar adds a new [MenuBar] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMenuBar(par ki.Ki, name ...string) *MenuBar {
	return par.NewChild(MenuBarType, name...).(*MenuBar)
}

// KiType returns the [*gti.Type] of [MenuBar]
func (t *MenuBar) KiType() *gti.Type {
	return MenuBarType
}

// New returns a new [*MenuBar] value
func (t *MenuBar) New() ki.Ki {
	return &MenuBar{}
}

// ToolBarType is the [gti.Type] for [ToolBar]
var ToolBarType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.ToolBar",
	ShortName: "gi.ToolBar",
	IDName:    "tool-bar",
	Doc:       "ToolBar is a [Frame] that is useful for holding [Button]s that do things.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ToolBar{},
})

// NewToolBar adds a new [ToolBar] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewToolBar(par ki.Ki, name ...string) *ToolBar {
	return par.NewChild(ToolBarType, name...).(*ToolBar)
}

// KiType returns the [*gti.Type] of [ToolBar]
func (t *ToolBar) KiType() *gti.Type {
	return ToolBarType
}

// New returns a new [*ToolBar] value
func (t *ToolBar) New() ki.Ki {
	return &ToolBar{}
}

// ToolBarEmbedder is an interface that all types that embed ToolBar satisfy
type ToolBarEmbedder interface {
	AsToolBar() *ToolBar
}

// AsToolBar returns the given value as a value of type ToolBar if the type
// of the given value embeds ToolBar, or nil otherwise
func AsToolBar(k ki.Ki) *ToolBar {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ToolBarEmbedder); ok {
		return t.AsToolBar()
	}
	return nil
}

// AsToolBar satisfies the [ToolBarEmbedder] interface
func (t *ToolBar) AsToolBar() *ToolBar {
	return t
}

// BitmapType is the [gti.Type] for [Bitmap]
var BitmapType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Bitmap",
	ShortName:  "gi.Bitmap",
	IDName:     "bitmap",
	Doc:        "Bitmap is a Widget that is optimized to render a static bitmap image --\nit expects to be a terminal node and does NOT call rendering etc on its\nchildren.  It is particularly useful for overlays in drag-n-drop uses --\ncan grab the image of another vp and show that",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Filename", &gti.Field{Name: "Filename", Type: "FileName", Doc: "file name of image loaded -- set by OpenImage", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "image.Point", Doc: "size of the image", Directives: gti.Directives{}}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", Doc: "[view: -] the bitmap image", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Bitmap{},
})

// NewBitmap adds a new [Bitmap] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewBitmap(par ki.Ki, name ...string) *Bitmap {
	return par.NewChild(BitmapType, name...).(*Bitmap)
}

// KiType returns the [*gti.Type] of [Bitmap]
func (t *Bitmap) KiType() *gti.Type {
	return BitmapType
}

// New returns a new [*Bitmap] value
func (t *Bitmap) New() ki.Ki {
	return &Bitmap{}
}

// ButtonType is the [gti.Type] for [Button]
var ButtonType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Button",
	ShortName: "gi.Button",
	IDName:    "button",
	Doc:       "Button is a pressable button with text, an icon, an indicator, a shortcut,\nand/or a menu. The standard behavior is to register a click event with OnClick(...).",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "ButtonTypes", Doc: "the type of button", Directives: gti.Directives{}}},
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "label for the button -- if blank then no label is presented", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "icons.Icon", Doc: "[view: show-name] optional icon for the button -- different buttons can configure this in different ways relative to the text if both are present", Directives: gti.Directives{}}},
		{"Indicator", &gti.Field{Name: "Indicator", Type: "icons.Icon", Doc: "[view: show-name] name of the menu indicator icon to present, or blank or 'nil' or 'none' -- shown automatically when there are Menu elements present unless 'none' is set", Directives: gti.Directives{}}},
		{"Shortcut", &gti.Field{Name: "Shortcut", Type: "key.Chord", Doc: "optional shortcut keyboard chord to trigger this button -- always window-wide in scope, and should generally not conflict other shortcuts (a log message will be emitted if so).  Shortcuts are processed after all other processing of keyboard input.  Use Command for Control / Meta (Mac Command key) per platform.  These are only set automatically for Menu items, NOT for items in ToolBar or buttons somewhere, but the tooltip for buttons will show the shortcut if set.", Directives: gti.Directives{}}},
		{"Menu", &gti.Field{Name: "Menu", Type: "Menu", Doc: "the menu items for this menu -- typically add Button elements for menus, along with separators", Directives: gti.Directives{}}},
		{"MakeMenuFunc", &gti.Field{Name: "MakeMenuFunc", Type: "MakeMenuFunc", Doc: "[view: -] set this to make a menu on demand -- if set then this button acts like a menu button", Directives: gti.Directives{}}},
		{"Data", &gti.Field{Name: "Data", Type: "any", Doc: "[view: -] optional data that is sent with events to identify the button", Directives: gti.Directives{}}},
		{"UpdateFunc", &gti.Field{Name: "UpdateFunc", Type: "func(bt *Button)", Doc: "[view: -] optional function that is called to update state of button (typically updating Active state); called automatically for menus prior to showing", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Button{},
})

// NewButton adds a new [Button] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewButton(par ki.Ki, name ...string) *Button {
	return par.NewChild(ButtonType, name...).(*Button)
}

// KiType returns the [*gti.Type] of [Button]
func (t *Button) KiType() *gti.Type {
	return ButtonType
}

// New returns a new [*Button] value
func (t *Button) New() ki.Ki {
	return &Button{}
}

// ButtonEmbedder is an interface that all types that embed Button satisfy
type ButtonEmbedder interface {
	AsButton() *Button
}

// AsButton returns the given value as a value of type Button if the type
// of the given value embeds Button, or nil otherwise
func AsButton(k ki.Ki) *Button {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ButtonEmbedder); ok {
		return t.AsButton()
	}
	return nil
}

// AsButton satisfies the [ButtonEmbedder] interface
func (t *Button) AsButton() *Button {
	return t
}

// ButtonBoxType is the [gti.Type] for [ButtonBox]
var ButtonBoxType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.ButtonBox",
	ShortName: "gi.ButtonBox",
	IDName:    "button-box",
	Doc:       "ButtonBox is a widget for containing a set of switches.\nIt can optionally enforce mutual exclusivity (i.e., Radio Buttons).\nThe buttons are all in the Parts of the widget and the Parts layout\ndetermines how they are displayed.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Items", &gti.Field{Name: "Items", Type: "[]string", Doc: "the list of items (switch labels)", Directives: gti.Directives{}}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", Doc: "an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}}},
		{"Mutex", &gti.Field{Name: "Mutex", Type: "bool", Doc: "make the items mutually exclusive -- checking one turns off all the others", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ButtonBox{},
})

// NewButtonBox adds a new [ButtonBox] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewButtonBox(par ki.Ki, name ...string) *ButtonBox {
	return par.NewChild(ButtonBoxType, name...).(*ButtonBox)
}

// KiType returns the [*gti.Type] of [ButtonBox]
func (t *ButtonBox) KiType() *gti.Type {
	return ButtonBoxType
}

// New returns a new [*ButtonBox] value
func (t *ButtonBox) New() ki.Ki {
	return &ButtonBox{}
}

// ButtonBoxEmbedder is an interface that all types that embed ButtonBox satisfy
type ButtonBoxEmbedder interface {
	AsButtonBox() *ButtonBox
}

// AsButtonBox returns the given value as a value of type ButtonBox if the type
// of the given value embeds ButtonBox, or nil otherwise
func AsButtonBox(k ki.Ki) *ButtonBox {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ButtonBoxEmbedder); ok {
		return t.AsButtonBox()
	}
	return nil
}

// AsButtonBox satisfies the [ButtonBoxEmbedder] interface
func (t *ButtonBox) AsButtonBox() *ButtonBox {
	return t
}

// ChooserType is the [gti.Type] for [Chooser]
var ChooserType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Chooser",
	ShortName:  "gi.Chooser",
	IDName:     "chooser",
	Doc:        "Chooser is for selecting items from a dropdown list, with an optional\nedit TextField for typing directly.\nThe items can be of any type, including enum values -- they are converted\nto strings for the display.  If the items are of type [icons.Icon], then they\nare displayed using icons instead.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "ComboBoxTypes", Doc: "the type of combo box", Directives: gti.Directives{}}},
		{"Editable", &gti.Field{Name: "Editable", Type: "bool", Doc: "provide a text field for editing the value, or just a button for selecting items?  Set the editable property", Directives: gti.Directives{}}},
		{"AllowNew", &gti.Field{Name: "AllowNew", Type: "bool", Doc: "whether to allow the user to add new items to the combo box through the editable textfield (if Editable is set to true) and a button at the end of the combo box menu", Directives: gti.Directives{}}},
		{"CurVal", &gti.Field{Name: "CurVal", Type: "any", Doc: "current selected value", Directives: gti.Directives{}}},
		{"CurIndex", &gti.Field{Name: "CurIndex", Type: "int", Doc: "current index in list of possible items", Directives: gti.Directives{}}},
		{"Items", &gti.Field{Name: "Items", Type: "[]any", Doc: "items available for selection", Directives: gti.Directives{}}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", Doc: "an optional list of tooltips displayed on hover for combobox items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", Doc: "if Editable is set to true, text that is displayed in the text field when it is empty, in a lower-contrast manner", Directives: gti.Directives{}}},
		{"MaxLength", &gti.Field{Name: "MaxLength", Type: "int", Doc: "maximum label length (in runes)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Button", &gti.Field{Name: "Button", Type: "Button", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Chooser{},
})

// NewChooser adds a new [Chooser] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewChooser(par ki.Ki, name ...string) *Chooser {
	return par.NewChild(ChooserType, name...).(*Chooser)
}

// KiType returns the [*gti.Type] of [Chooser]
func (t *Chooser) KiType() *gti.Type {
	return ChooserType
}

// New returns a new [*Chooser] value
func (t *Chooser) New() ki.Ki {
	return &Chooser{}
}

// CompleteType is the [gti.Type] for [Complete]
var CompleteType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Complete",
	ShortName:  "gi.Complete",
	IDName:     "complete",
	Doc:        "Complete holds the current completion data and functions to call for building\nthe list of possible completions and for editing text after a completion is selected",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MatchFunc", &gti.Field{Name: "MatchFunc", Type: "complete.MatchFunc", Doc: "function to get the list of possible completions", Directives: gti.Directives{}}},
		{"LookupFunc", &gti.Field{Name: "LookupFunc", Type: "complete.LookupFunc", Doc: "function to get the text to show for lookup", Directives: gti.Directives{}}},
		{"EditFunc", &gti.Field{Name: "EditFunc", Type: "complete.EditFunc", Doc: "function to edit text using the selected completion", Directives: gti.Directives{}}},
		{"Context", &gti.Field{Name: "Context", Type: "any", Doc: "the object that implements complete.Func", Directives: gti.Directives{}}},
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", Doc: "line number in source that completion is operating on, if relevant", Directives: gti.Directives{}}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", Doc: "character position in source that completion is operating on", Directives: gti.Directives{}}},
		{"Completions", &gti.Field{Name: "Completions", Type: "complete.Completions", Doc: "the list of potential completions", Directives: gti.Directives{}}},
		{"Seed", &gti.Field{Name: "Seed", Type: "string", Doc: "current completion seed", Directives: gti.Directives{}}},
		{"Completion", &gti.Field{Name: "Completion", Type: "string", Doc: "the user's completion selection'", Directives: gti.Directives{}}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*Scene", Doc: "the scene where the current popup menu is presented", Directives: gti.Directives{}}},
		{"DelayTimer", &gti.Field{Name: "DelayTimer", Type: "*time.Timer", Doc: "", Directives: gti.Directives{}}},
		{"DelayMu", &gti.Field{Name: "DelayMu", Type: "sync.Mutex", Doc: "", Directives: gti.Directives{}}},
		{"ShowMu", &gti.Field{Name: "ShowMu", Type: "sync.Mutex", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Complete{},
})

// NewComplete adds a new [Complete] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewComplete(par ki.Ki, name ...string) *Complete {
	return par.NewChild(CompleteType, name...).(*Complete)
}

// KiType returns the [*gti.Type] of [Complete]
func (t *Complete) KiType() *gti.Type {
	return CompleteType
}

// New returns a new [*Complete] value
func (t *Complete) New() ki.Ki {
	return &Complete{}
}

// StyleSheetType is the [gti.Type] for [StyleSheet]
var StyleSheetType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.StyleSheet",
	ShortName:  "gi.StyleSheet",
	IDName:     "style-sheet",
	Doc:        "StyleSheet is a Widget node that contains a stylesheet -- property values\ncontained in this sheet can be transformed into ki.Props and set in CSS\nfield of appropriate node",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Sheet", &gti.Field{Name: "Sheet", Type: "*css.Stylesheet", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StyleSheet{},
})

// NewStyleSheet adds a new [StyleSheet] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStyleSheet(par ki.Ki, name ...string) *StyleSheet {
	return par.NewChild(StyleSheetType, name...).(*StyleSheet)
}

// KiType returns the [*gti.Type] of [StyleSheet]
func (t *StyleSheet) KiType() *gti.Type {
	return StyleSheetType
}

// New returns a new [*StyleSheet] value
func (t *StyleSheet) New() ki.Ki {
	return &StyleSheet{}
}

// FrameType is the [gti.Type] for [Frame]
var FrameType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Frame",
	ShortName:  "gi.Frame",
	IDName:     "frame",
	Doc:        "Frame is a Layout that renders a background according to the\nbackground-color style setting, and optional striping for grid layouts",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stripes", &gti.Field{Name: "Stripes", Type: "Stripes", Doc: "options for striped backgrounds -- rendered as darker bands relative to background color", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Frame{},
})

// NewFrame adds a new [Frame] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFrame(par ki.Ki, name ...string) *Frame {
	return par.NewChild(FrameType, name...).(*Frame)
}

// KiType returns the [*gti.Type] of [Frame]
func (t *Frame) KiType() *gti.Type {
	return FrameType
}

// New returns a new [*Frame] value
func (t *Frame) New() ki.Ki {
	return &Frame{}
}

// IconType is the [gti.Type] for [Icon]
var IconType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Icon",
	ShortName:  "gi.Icon",
	IDName:     "icon",
	Doc:        "Icon contains a svg.SVG element.\nThe rendered version is cached for a given size.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IconName", &gti.Field{Name: "IconName", Type: "icons.Icon", Doc: "icon name that has been set.", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "file name for the loaded icon, if loaded", Directives: gti.Directives{}}},
		{"SVG", &gti.Field{Name: "SVG", Type: "svg.SVG", Doc: "SVG drawing", Directives: gti.Directives{}}},
		{"RendSize", &gti.Field{Name: "RendSize", Type: "image.Point", Doc: "RendSize is the last rendered size of the Icon SVG.\nif the SVG.Name == IconName and this size is the same\nthen the current SVG image is used.", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Icon{},
})

// NewIcon adds a new [Icon] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewIcon(par ki.Ki, name ...string) *Icon {
	return par.NewChild(IconType, name...).(*Icon)
}

// KiType returns the [*gti.Type] of [Icon]
func (t *Icon) KiType() *gti.Type {
	return IconType
}

// New returns a new [*Icon] value
func (t *Icon) New() ki.Ki {
	return &Icon{}
}

// LabelType is the [gti.Type] for [Label]
var LabelType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Label",
	ShortName: "gi.Label",
	IDName:    "label",
	Doc:       "Label is a widget for rendering text labels -- supports full widget model\nincluding box rendering, and full HTML styling, including links -- LinkSig\nemits link with data of URL -- opens default browser if nobody receiving\nsignal.  The default white-space option is 'pre' -- set to 'normal' or\nother options to get word-wrapping etc.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "label to display", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "LabelTypes", Doc: "the type of label", Directives: gti.Directives{}}},
		{"TextRender", &gti.Field{Name: "TextRender", Type: "paint.Text", Doc: "render data for text label", Directives: gti.Directives{}}},
		{"RenderPos", &gti.Field{Name: "RenderPos", Type: "mat32.Vec2", Doc: "position offset of start of text rendering, from last render -- AllocPos plus alignment factors for center, right etc.", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Label{},
})

// NewLabel adds a new [Label] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewLabel(par ki.Ki, name ...string) *Label {
	return par.NewChild(LabelType, name...).(*Label)
}

// KiType returns the [*gti.Type] of [Label]
func (t *Label) KiType() *gti.Type {
	return LabelType
}

// New returns a new [*Label] value
func (t *Label) New() ki.Ki {
	return &Label{}
}

// LabelEmbedder is an interface that all types that embed Label satisfy
type LabelEmbedder interface {
	AsLabel() *Label
}

// AsLabel returns the given value as a value of type Label if the type
// of the given value embeds Label, or nil otherwise
func AsLabel(k ki.Ki) *Label {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(LabelEmbedder); ok {
		return t.AsLabel()
	}
	return nil
}

// AsLabel satisfies the [LabelEmbedder] interface
func (t *Label) AsLabel() *Label {
	return t
}

// LayoutType is the [gti.Type] for [Layout]
var LayoutType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Layout",
	ShortName: "gi.Layout",
	IDName:    "layout",
	Doc:       "Layout is the primary node type responsible for organizing the sizes\nand positions of child widgets. It does not render, only organize,\nso properties like background color will have no effect.\nAll arbitrary collections of widgets should generally be contained\nwithin a layout -- otherwise the parent widget must take over\nresponsibility for positioning.\nThe alignment is NOT inherited by default so must be specified per\nchild, except that the parent alignment is used within the relevant\ndimension (e.g., horizontal-align for a LayoutHoriz layout,\nto determine left, right, center, justified).\nLayouts can automatically add scrollbars depending on the Overflow\nlayout style.\nFor a Grid layout, the 'columns' property should generally be set\nto the desired number of columns, from which the number of rows\nis computed -- otherwise it uses the square root of number of\nelements.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Lay", &gti.Field{Name: "Lay", Type: "Layouts", Doc: "type of layout to use", Directives: gti.Directives{}}},
		{"Spacing", &gti.Field{Name: "Spacing", Type: "units.Value", Doc: "extra space to add between elements in the layout", Directives: gti.Directives{}}},
		{"StackTop", &gti.Field{Name: "StackTop", Type: "int", Doc: "for Stacked layout, index of node to use as the top of the stack -- only node at this index is rendered -- if not a valid index, nothing is rendered", Directives: gti.Directives{}}},
		{"StackTopOnly", &gti.Field{Name: "StackTopOnly", Type: "bool", Doc: "for stacked layout, only layout the top widget -- this is appropriate for e.g., tab layout, which does a full redraw on stack changes, but not for e.g., check boxes which don't", Directives: gti.Directives{}}},
		{"ChildSize", &gti.Field{Name: "ChildSize", Type: "mat32.Vec2", Doc: "total max size of children as laid out", Directives: gti.Directives{}}},
		{"ExtraSize", &gti.Field{Name: "ExtraSize", Type: "mat32.Vec2", Doc: "extra size in each dim due to scrollbars we add", Directives: gti.Directives{}}},
		{"HasScroll", &gti.Field{Name: "HasScroll", Type: "[2]bool", Doc: "whether scrollbar is used for given dim", Directives: gti.Directives{}}},
		{"Scrolls", &gti.Field{Name: "Scrolls", Type: "[2]*Slider", Doc: "scroll bars -- we fully manage them as needed", Directives: gti.Directives{}}},
		{"GridSize", &gti.Field{Name: "GridSize", Type: "image.Point", Doc: "computed size of a grid layout based on all the constraints -- computed during GetSize pass", Directives: gti.Directives{}}},
		{"GridData", &gti.Field{Name: "GridData", Type: "[RowColN][]GridData", Doc: "grid data for rows in [0] and cols in [1]", Directives: gti.Directives{}}},
		{"FlowBreaks", &gti.Field{Name: "FlowBreaks", Type: "[]int", Doc: "line breaks for flow layout", Directives: gti.Directives{}}},
		{"NeedsRedo", &gti.Field{Name: "NeedsRedo", Type: "bool", Doc: "true if this layout got a redo = true on previous iteration -- otherwise it just skips any re-layout on subsequent iteration", Directives: gti.Directives{}}},
		{"FocusName", &gti.Field{Name: "FocusName", Type: "string", Doc: "accumulated name to search for when keys are typed", Directives: gti.Directives{}}},
		{"FocusNameTime", &gti.Field{Name: "FocusNameTime", Type: "time.Time", Doc: "time of last focus name event -- for timeout", Directives: gti.Directives{}}},
		{"FocusNameLast", &gti.Field{Name: "FocusNameLast", Type: "ki.Ki", Doc: "last element focused on -- used as a starting point if name is the same", Directives: gti.Directives{}}},
		{"ScrollsOff", &gti.Field{Name: "ScrollsOff", Type: "bool", Doc: "scrollbars have been manually turned off due to layout being invisible -- must be reactivated when re-visible", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Layout{},
})

// NewLayout adds a new [Layout] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewLayout(par ki.Ki, name ...string) *Layout {
	return par.NewChild(LayoutType, name...).(*Layout)
}

// KiType returns the [*gti.Type] of [Layout]
func (t *Layout) KiType() *gti.Type {
	return LayoutType
}

// New returns a new [*Layout] value
func (t *Layout) New() ki.Ki {
	return &Layout{}
}

// LayoutEmbedder is an interface that all types that embed Layout satisfy
type LayoutEmbedder interface {
	AsLayout() *Layout
}

// AsLayout returns the given value as a value of type Layout if the type
// of the given value embeds Layout, or nil otherwise
func AsLayout(k ki.Ki) *Layout {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(LayoutEmbedder); ok {
		return t.AsLayout()
	}
	return nil
}

// AsLayout satisfies the [LayoutEmbedder] interface
func (t *Layout) AsLayout() *Layout {
	return t
}

// StretchType is the [gti.Type] for [Stretch]
var StretchType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Stretch",
	ShortName:  "gi.Stretch",
	IDName:     "stretch",
	Doc:        "Stretch adds an infinitely stretchy element for spacing out layouts\n(max-size = -1) set the width / height property to determine how much it\ntakes relative to other stretchy elements",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Stretch{},
})

// NewStretch adds a new [Stretch] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStretch(par ki.Ki, name ...string) *Stretch {
	return par.NewChild(StretchType, name...).(*Stretch)
}

// KiType returns the [*gti.Type] of [Stretch]
func (t *Stretch) KiType() *gti.Type {
	return StretchType
}

// New returns a new [*Stretch] value
func (t *Stretch) New() ki.Ki {
	return &Stretch{}
}

// SpaceType is the [gti.Type] for [Space]
var SpaceType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Space",
	ShortName:  "gi.Space",
	IDName:     "space",
	Doc:        "Space adds a fixed sized (1 ch x 1 em by default) blank space to a layout -- set\nwidth / height property to change",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Space{},
})

// NewSpace adds a new [Space] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSpace(par ki.Ki, name ...string) *Space {
	return par.NewChild(SpaceType, name...).(*Space)
}

// KiType returns the [*gti.Type] of [Space]
func (t *Space) KiType() *gti.Type {
	return SpaceType
}

// New returns a new [*Space] value
func (t *Space) New() ki.Ki {
	return &Space{}
}

// SeparatorType is the [gti.Type] for [Separator]
var SeparatorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Separator",
	ShortName:  "gi.Separator",
	IDName:     "separator",
	Doc:        "Separator draws a vertical or horizontal line",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Horiz", &gti.Field{Name: "Horiz", Type: "bool", Doc: "is this a horizontal separator -- otherwise vertical", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Separator{},
})

// NewSeparator adds a new [Separator] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSeparator(par ki.Ki, name ...string) *Separator {
	return par.NewChild(SeparatorType, name...).(*Separator)
}

// KiType returns the [*gti.Type] of [Separator]
func (t *Separator) KiType() *gti.Type {
	return SeparatorType
}

// New returns a new [*Separator] value
func (t *Separator) New() ki.Ki {
	return &Separator{}
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.EditorPrefs",
	ShortName: "gi.EditorPrefs",
	IDName:    "editor-prefs",
	Doc:       "EditorPrefs contains editor preferences.  It can also be set\nfrom ki.Props style properties.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TabSize", &gti.Field{Name: "TabSize", Type: "int", Doc: "size of a tab, in chars -- also determines indent level for space indent", Directives: gti.Directives{}}},
		{"SpaceIndent", &gti.Field{Name: "SpaceIndent", Type: "bool", Doc: "use spaces for indentation, otherwise tabs", Directives: gti.Directives{}}},
		{"WordWrap", &gti.Field{Name: "WordWrap", Type: "bool", Doc: "wrap lines at word boundaries -- otherwise long lines scroll off the end", Directives: gti.Directives{}}},
		{"LineNos", &gti.Field{Name: "LineNos", Type: "bool", Doc: "show line numbers", Directives: gti.Directives{}}},
		{"Completion", &gti.Field{Name: "Completion", Type: "bool", Doc: "use the completion system to suggest options while typing", Directives: gti.Directives{}}},
		{"SpellCorrect", &gti.Field{Name: "SpellCorrect", Type: "bool", Doc: "suggest corrections for unknown words while typing", Directives: gti.Directives{}}},
		{"AutoIndent", &gti.Field{Name: "AutoIndent", Type: "bool", Doc: "automatically indent lines when enter, tab, }, etc pressed", Directives: gti.Directives{}}},
		{"EmacsUndo", &gti.Field{Name: "EmacsUndo", Type: "bool", Doc: "use emacs-style undo, where after a non-undo command, all the current undo actions are added to the undo stack, such that a subsequent undo is actually a redo", Directives: gti.Directives{}}},
		{"DepthColor", &gti.Field{Name: "DepthColor", Type: "bool", Doc: "colorize the background according to nesting depth", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.FavPathItem",
	ShortName: "gi.FavPathItem",
	IDName:    "fav-path-item",
	Doc:       "FavPathItem represents one item in a favorite path list, for display of\nfavorites.  Is an ordered list instead of a map because user can organize\nin order",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Ic", &gti.Field{Name: "Ic", Type: "icons.Icon", Doc: "icon for item", Directives: gti.Directives{}}},
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "name of the favorite item", Directives: gti.Directives{}}},
		{"Path", &gti.Field{Name: "Path", Type: "string", Doc: "[tableview: -select]", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SceneType is the [gti.Type] for [Scene]
var SceneType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Scene",
	ShortName:  "gi.Scene",
	IDName:     "scene",
	Doc:        "Scene contains a Widget tree, rooted in an embedded Frame layout,\nwhich renders into its Pixels image.\nThe Scene is set in a Stage (pointer retained in Scene).\nStage has a StageMgr manager for controlling things like Popups\n(Menus and Dialogs, etc).\n\nEach Scene and Widget tree contains state specific to its particular usage\nwithin a given Stage and overall rendering context (e.g., bounding boxes\nand pointer to current parent Stage), so",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Nm", &gti.Field{Name: "Nm", Type: "string", Doc: "name of scene.  User-created scenes can be stored in the global SceneLibrary by name, in which case they must be unique.", Directives: gti.Directives{}}},
		{"Title", &gti.Field{Name: "Title", Type: "string", Doc: "title of the Stage -- generally auto-set based on Scene Title.  used for title of Window and Dialog types", Directives: gti.Directives{}}},
		{"Data", &gti.Field{Name: "Data", Type: "any", Doc: "Data is the optional data value being represented by this scene.\nUsed e.g., for recycling views of a given item instead of creating new one.", Directives: gti.Directives{}}},
		{"Flags", &gti.Field{Name: "Flags", Type: "ScFlags", Doc: "has critical state information signaling when rendering, styling etc need to be done, and also indicates type of scene", Directives: gti.Directives{}}},
		{"Geom", &gti.Field{Name: "Geom", Type: "mat32.Geom2DInt", Doc: "Size and position relative to overall rendering context.", Directives: gti.Directives{}}},
		{"Decor", &gti.Field{Name: "Decor", Type: "Layout", Doc: "Extra decoration, configured by the outer Stage container.  Can be positioned anywhere -- typically uses LayoutNil", Directives: gti.Directives{}}},
		{"RenderState", &gti.Field{Name: "RenderState", Type: "paint.State", Doc: "[view: -] render state for rendering", Directives: gti.Directives{}}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", Doc: "[view: -] live pixels that we render into", Directives: gti.Directives{}}},
		{"BgColor", &gti.Field{Name: "BgColor", Type: "colors.Full", Doc: "background color for filling scene -- defaults to transparent so that popups can have rounded corners", Directives: gti.Directives{}}},
		{"EventMgr", &gti.Field{Name: "EventMgr", Type: "EventMgr", Doc: "event manager for this scene", Directives: gti.Directives{}}},
		{"Stage", &gti.Field{Name: "Stage", Type: "Stage", Doc: "current stage in which this Scene is set", Directives: gti.Directives{}}},
		{"CurColor", &gti.Field{Name: "CurColor", Type: "color.RGBA", Doc: "[view: -] Current color in styling -- used for relative color names", Directives: gti.Directives{}}},
		{"LastRender", &gti.Field{Name: "LastRender", Type: "RenderParams", Doc: "LastRender captures key params from last render.\nIf different then a new ApplyStyleScene is needed.", Directives: gti.Directives{}}},
		{"StyleMu", &gti.Field{Name: "StyleMu", Type: "sync.RWMutex", Doc: "[view: -] StyleMu is RW mutex protecting access to Style-related global vars", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Frame", &gti.Field{Name: "Frame", Type: "Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Scene{},
})

// NewScene adds a new [Scene] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewScene(par ki.Ki, name ...string) *Scene {
	return par.NewChild(SceneType, name...).(*Scene)
}

// KiType returns the [*gti.Type] of [Scene]
func (t *Scene) KiType() *gti.Type {
	return SceneType
}

// New returns a new [*Scene] value
func (t *Scene) New() ki.Ki {
	return &Scene{}
}

// SliderType is the [gti.Type] for [Slider]
var SliderType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Slider",
	ShortName: "gi.Slider",
	IDName:    "slider",
	Doc:       "Slider is a slideable widget that provides slider functionality for two major modes.\nValThumb = false is a slider with a fixed-size thumb knob, while = true has a thumb\nthat represents a value, as in a scrollbar, and the scrolling range is size - thumbsize",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "SliderTypes", Doc: "the type of the slider", Directives: gti.Directives{}}},
		{"Value", &gti.Field{Name: "Value", Type: "float32", Doc: "current value", Directives: gti.Directives{}}},
		{"Dim", &gti.Field{Name: "Dim", Type: "mat32.Dims", Doc: "dimension along which the slider slides", Directives: gti.Directives{}}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", Doc: "minimum value in range", Directives: gti.Directives{}}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", Doc: "maximum value in range", Directives: gti.Directives{}}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}}},
		{"ValThumb", &gti.Field{Name: "ValThumb", Type: "bool", Doc: "if true, has a proportionally-sized thumb knob reflecting another value -- e.g., the amount visible in a scrollbar, and thumb is completely inside Size -- otherwise ThumbSize affects Size so that full Size range can be traversed", Directives: gti.Directives{}}},
		{"ThumbVal", &gti.Field{Name: "ThumbVal", Type: "float32", Doc: "value that the thumb represents, in the same units", Directives: gti.Directives{}}},
		{"ThumbSize", &gti.Field{Name: "ThumbSize", Type: "units.Value", Doc: "styled fixed size of the thumb -- only if not doing ValThumb", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "icons.Icon", Doc: "[view: show-name] optional icon for the dragging knob", Directives: gti.Directives{}}},
		{"Tracking", &gti.Field{Name: "Tracking", Type: "bool", Doc: "if true, will send continuous updates of value changes as user moves the slider -- otherwise only at the end -- see TrackThr for a threshold on amount of change", Directives: gti.Directives{}}},
		{"TrackThr", &gti.Field{Name: "TrackThr", Type: "float32", Doc: "threshold for amount of change in scroll value before emitting a signal in Tracking mode", Directives: gti.Directives{}}},
		{"Snap", &gti.Field{Name: "Snap", Type: "bool", Doc: "snap the values to Step size increments", Directives: gti.Directives{}}},
		{"Off", &gti.Field{Name: "Off", Type: "bool", Doc: "can turn off e.g., scrollbar rendering with this flag -- just prevents rendering", Directives: gti.Directives{}}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}}},
		{"ValueColor", &gti.Field{Name: "ValueColor", Type: "colors.Full", Doc: "the background color that is used for styling the selected value section of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}}},
		{"ThumbColor", &gti.Field{Name: "ThumbColor", Type: "colors.Full", Doc: "the background color that is used for styling the thumb (handle) of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}}},
		{"StyleBox", &gti.Field{Name: "StyleBox", Type: "styles.Style", Doc: "an additional style object that is used for styling the overall box around the slider; it should be set in the StyleFuncs, just the like the main style object is; it typically has no border and a white/black background; it needs a background to allow local re-rendering", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "float32", Doc: "logical position of the slider relative to Size", Directives: gti.Directives{}}},
		{"LastValue", &gti.Field{Name: "LastValue", Type: "float32", Doc: "previous emitted value - don't re-emit if it is the same", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "float32", Doc: "computed size of the slide box in the relevant dimension -- range of motion -- exclusive of spacing -- based on layout allocation", Directives: gti.Directives{}}},
		{"ThSize", &gti.Field{Name: "ThSize", Type: "float32", Doc: "computed size of the thumb -- if ValThumb then this is auto-sized based on ThumbVal and is subtracted from Size in computing Value -- this is the display size version subject to SliderMinThumbSize", Directives: gti.Directives{}}},
		{"ThSizeReal", &gti.Field{Name: "ThSizeReal", Type: "float32", Doc: "computed size of the thumb, without any SliderMinThumbSize limitation -- use this for more accurate calculations of true value", Directives: gti.Directives{}}},
		{"SlideStartPos", &gti.Field{Name: "SlideStartPos", Type: "float32", Doc: "underlying drag position of slider -- not subject to snapping", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Slider{},
})

// NewSlider adds a new [Slider] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSlider(par ki.Ki, name ...string) *Slider {
	return par.NewChild(SliderType, name...).(*Slider)
}

// KiType returns the [*gti.Type] of [Slider]
func (t *Slider) KiType() *gti.Type {
	return SliderType
}

// New returns a new [*Slider] value
func (t *Slider) New() ki.Ki {
	return &Slider{}
}

// SliderEmbedder is an interface that all types that embed Slider satisfy
type SliderEmbedder interface {
	AsSlider() *Slider
}

// AsSlider returns the given value as a value of type Slider if the type
// of the given value embeds Slider, or nil otherwise
func AsSlider(k ki.Ki) *Slider {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SliderEmbedder); ok {
		return t.AsSlider()
	}
	return nil
}

// AsSlider satisfies the [SliderEmbedder] interface
func (t *Slider) AsSlider() *Slider {
	return t
}

// SpinnerType is the [gti.Type] for [Spinner]
var SpinnerType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Spinner",
	ShortName: "gi.Spinner",
	IDName:    "spinner",
	Doc:       "Spinner combines a TextField with up / down buttons for incrementing /\ndecrementing values -- all configured within the Parts of the widget",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "float32", Doc: "current value", Directives: gti.Directives{}}},
		{"HasMin", &gti.Field{Name: "HasMin", Type: "bool", Doc: "is there a minimum value to enforce", Directives: gti.Directives{}}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", Doc: "minimum value in range", Directives: gti.Directives{}}},
		{"HasMax", &gti.Field{Name: "HasMax", Type: "bool", Doc: "is there a maximumvalue to enforce", Directives: gti.Directives{}}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", Doc: "maximum value in range", Directives: gti.Directives{}}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "string", Doc: "prop = format -- format string for printing the value -- blank defaults to %g.  If decimal based (ends in d, b, c, o, O, q, x, X, or U) then value is converted to decimal prior to printing", Directives: gti.Directives{}}},
		{"UpIcon", &gti.Field{Name: "UpIcon", Type: "icons.Icon", Doc: "[view: show-name] icon to use for up button -- defaults to [icons.Add]", Directives: gti.Directives{}}},
		{"DownIcon", &gti.Field{Name: "DownIcon", Type: "icons.Icon", Doc: "[view: show-name] icon to use for down button -- defaults to [icons.Remove]", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Spinner{},
})

// NewSpinner adds a new [Spinner] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSpinner(par ki.Ki, name ...string) *Spinner {
	return par.NewChild(SpinnerType, name...).(*Spinner)
}

// KiType returns the [*gti.Type] of [Spinner]
func (t *Spinner) KiType() *gti.Type {
	return SpinnerType
}

// New returns a new [*Spinner] value
func (t *Spinner) New() ki.Ki {
	return &Spinner{}
}

// SpinnerEmbedder is an interface that all types that embed Spinner satisfy
type SpinnerEmbedder interface {
	AsSpinner() *Spinner
}

// AsSpinner returns the given value as a value of type Spinner if the type
// of the given value embeds Spinner, or nil otherwise
func AsSpinner(k ki.Ki) *Spinner {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SpinnerEmbedder); ok {
		return t.AsSpinner()
	}
	return nil
}

// AsSpinner satisfies the [SpinnerEmbedder] interface
func (t *Spinner) AsSpinner() *Spinner {
	return t
}

// SplitsType is the [gti.Type] for [Splits]
var SplitsType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Splits",
	ShortName: "gi.Splits",
	IDName:    "splits",
	Doc:       "Splits allocates a fixed proportion of space to each child, along given\ndimension, always using only the available space given to it by its parent\n(i.e., it will force its children, which should be layouts (typically\nFrame's), to have their own scroll bars as necessary).  It should\ngenerally be used as a main outer-level structure within a window,\nproviding a framework for inner elements -- it allows individual child\nelements to update independently and thus is important for speeding update\nperformance.  It uses the Widget Parts to hold the splitter widgets\nseparately from the children that contain the rest of the scenegraph to be\ndisplayed within each region.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"HandleSize", &gti.Field{Name: "HandleSize", Type: "units.Value", Doc: "size of the handle region in the middle of each split region, where the splitter can be dragged -- other-dimension size is 2x of this", Directives: gti.Directives{}}},
		{"Splits", &gti.Field{Name: "Splits", Type: "[]float32", Doc: "proportion (0-1 normalized, enforced) of space allocated to each element -- can enter 0 to collapse a given element", Directives: gti.Directives{}}},
		{"SavedSplits", &gti.Field{Name: "SavedSplits", Type: "[]float32", Doc: "A saved version of the splits which can be restored -- for dynamic collapse / expand operations", Directives: gti.Directives{}}},
		{"Dim", &gti.Field{Name: "Dim", Type: "mat32.Dims", Doc: "dimension along which to split the space", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Splits{},
})

// NewSplits adds a new [Splits] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSplits(par ki.Ki, name ...string) *Splits {
	return par.NewChild(SplitsType, name...).(*Splits)
}

// KiType returns the [*gti.Type] of [Splits]
func (t *Splits) KiType() *gti.Type {
	return SplitsType
}

// New returns a new [*Splits] value
func (t *Splits) New() ki.Ki {
	return &Splits{}
}

// SplitsEmbedder is an interface that all types that embed Splits satisfy
type SplitsEmbedder interface {
	AsSplits() *Splits
}

// AsSplits returns the given value as a value of type Splits if the type
// of the given value embeds Splits, or nil otherwise
func AsSplits(k ki.Ki) *Splits {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(SplitsEmbedder); ok {
		return t.AsSplits()
	}
	return nil
}

// AsSplits satisfies the [SplitsEmbedder] interface
func (t *Splits) AsSplits() *Splits {
	return t
}

// SplitterType is the [gti.Type] for [Splitter]
var SplitterType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Splitter",
	ShortName:  "gi.Splitter",
	IDName:     "splitter",
	Doc:        "Splitter provides the splitter handle and line separating two elements in a\nSplitView, with draggable resizing of the splitter -- parent is Parts\nlayout of the SplitView -- based on Slider",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SplitterNo", &gti.Field{Name: "SplitterNo", Type: "int", Doc: "splitter number this one is", Directives: gti.Directives{}}},
		{"OrigWinBBox", &gti.Field{Name: "OrigWinBBox", Type: "image.Rectangle", Doc: "copy of the win bbox, used for translating mouse events when the bbox is restricted to the slider itself", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Slider", &gti.Field{Name: "Slider", Type: "Slider", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Splitter{},
})

// NewSplitter adds a new [Splitter] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSplitter(par ki.Ki, name ...string) *Splitter {
	return par.NewChild(SplitterType, name...).(*Splitter)
}

// KiType returns the [*gti.Type] of [Splitter]
func (t *Splitter) KiType() *gti.Type {
	return SplitterType
}

// New returns a new [*Splitter] value
func (t *Splitter) New() ki.Ki {
	return &Splitter{}
}

// SwitchType is the [gti.Type] for [Switch]
var SwitchType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Switch",
	ShortName:  "gi.Switch",
	IDName:     "switch",
	Doc:        "Switch is a widget that can toggle between an on and off state.\nIt can be displayed as a switch, checkbox, or radio button.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Type", &gti.Field{Name: "Type", Type: "SwitchTypes", Doc: "the type of switch that this is", Directives: gti.Directives{}}},
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "the label text for the switch", Directives: gti.Directives{}}},
		{"IconOn", &gti.Field{Name: "IconOn", Type: "icons.Icon", Doc: "[view: show-name] icon to use for the on, checked state of the switch", Directives: gti.Directives{}}},
		{"IconOff", &gti.Field{Name: "IconOff", Type: "icons.Icon", Doc: "[view: show-name] icon to use for the off, unchecked state of the switch", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Switch{},
})

// NewSwitch adds a new [Switch] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSwitch(par ki.Ki, name ...string) *Switch {
	return par.NewChild(SwitchType, name...).(*Switch)
}

// KiType returns the [*gti.Type] of [Switch]
func (t *Switch) KiType() *gti.Type {
	return SwitchType
}

// New returns a new [*Switch] value
func (t *Switch) New() ki.Ki {
	return &Switch{}
}

// TabsType is the [gti.Type] for [Tabs]
var TabsType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.Tabs",
	ShortName: "gi.Tabs",
	IDName:    "tabs",
	Doc:       "Tabs switches among child widgets via tabs.  The selected widget gets\nthe full allocated space avail after the tabs are accounted for.  The\nTabs is just a Vertical layout that manages two child widgets: a\nHorizFlow Layout for the tabs (which can flow across multiple rows as\nneeded) and a Stacked Frame that actually contains all the children, and\nprovides scrollbars as needed to any content within.  Typically should have\nmax stretch and a set preferred size, so it expands.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MaxChars", &gti.Field{Name: "MaxChars", Type: "int", Doc: "maximum number of characters to include in tab label -- elides labels that are longer than that", Directives: gti.Directives{}}},
		{"NewTabButton", &gti.Field{Name: "NewTabButton", Type: "bool", Doc: "show a new tab button at right of list of tabs", Directives: gti.Directives{}}},
		{"NoDeleteTabs", &gti.Field{Name: "NoDeleteTabs", Type: "bool", Doc: "if true, tabs are not user-deleteable", Directives: gti.Directives{}}},
		{"Mu", &gti.Field{Name: "Mu", Type: "sync.Mutex", Doc: "[view: -] mutex protecting updates to tabs -- tabs can be driven programmatically and via user input so need extra protection", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Tabs{},
})

// NewTabs adds a new [Tabs] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTabs(par ki.Ki, name ...string) *Tabs {
	return par.NewChild(TabsType, name...).(*Tabs)
}

// KiType returns the [*gti.Type] of [Tabs]
func (t *Tabs) KiType() *gti.Type {
	return TabsType
}

// New returns a new [*Tabs] value
func (t *Tabs) New() ki.Ki {
	return &Tabs{}
}

// TabsEmbedder is an interface that all types that embed Tabs satisfy
type TabsEmbedder interface {
	AsTabs() *Tabs
}

// AsTabs returns the given value as a value of type Tabs if the type
// of the given value embeds Tabs, or nil otherwise
func AsTabs(k ki.Ki) *Tabs {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(TabsEmbedder); ok {
		return t.AsTabs()
	}
	return nil
}

// AsTabs satisfies the [TabsEmbedder] interface
func (t *Tabs) AsTabs() *Tabs {
	return t
}

// TabType is the [gti.Type] for [Tab]
var TabType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Tab",
	ShortName:  "gi.Tab",
	IDName:     "tab",
	Doc:        "Tab is a tab button that contains a larger select button\nand a small close button. The Indicator icon is used for\nthe close icon.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NoDelete", &gti.Field{Name: "NoDelete", Type: "bool", Doc: "if true, this tab does not have the delete button avail", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Button", &gti.Field{Name: "Button", Type: "Button", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Tab{},
})

// NewTab adds a new [Tab] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTab(par ki.Ki, name ...string) *Tab {
	return par.NewChild(TabType, name...).(*Tab)
}

// KiType returns the [*gti.Type] of [Tab]
func (t *Tab) KiType() *gti.Type {
	return TabType
}

// New returns a new [*Tab] value
func (t *Tab) New() ki.Ki {
	return &Tab{}
}

// TextFieldType is the [gti.Type] for [TextField]
var TextFieldType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/gi.TextField",
	ShortName: "gi.TextField",
	IDName:    "text-field",
	Doc:       "TextField is a widget for editing a line of text",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Txt", &gti.Field{Name: "Txt", Type: "string", Doc: "the last saved value of the text string being edited", Directives: gti.Directives{}}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", Doc: "text that is displayed when the field is empty, in a lower-contrast manner", Directives: gti.Directives{}}},
		{"Complete", &gti.Field{Name: "Complete", Type: "*Complete", Doc: "functions and data for textfield completion", Directives: gti.Directives{}}},
		{"NoEcho", &gti.Field{Name: "NoEcho", Type: "bool", Doc: "replace displayed characters with bullets to conceal text", Directives: gti.Directives{}}},
		{"LeadingIcon", &gti.Field{Name: "LeadingIcon", Type: "icons.Icon", Doc: "if specified, a button will be added at the start of the text field with this icon", Directives: gti.Directives{}}},
		{"TrailingIcon", &gti.Field{Name: "TrailingIcon", Type: "icons.Icon", Doc: "if specified, a button will be added at the end of the text field with this icon", Directives: gti.Directives{}}},
		{"CursorWidth", &gti.Field{Name: "CursorWidth", Type: "units.Value", Doc: "width of cursor -- set from cursor-width property (inherited)", Directives: gti.Directives{}}},
		{"Type", &gti.Field{Name: "Type", Type: "TextFieldTypes", Doc: "the type of the text field", Directives: gti.Directives{}}},
		{"PlaceholderColor", &gti.Field{Name: "PlaceholderColor", Type: "color.RGBA", Doc: "the color used for the placeholder text; this should be set in Stylers like all other style properties; it is typically a highlighted version of the normal text color", Directives: gti.Directives{}}},
		{"SelectColor", &gti.Field{Name: "SelectColor", Type: "colors.Full", Doc: "the color used for the text selection background color on active text fields; this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"CursorColor", &gti.Field{Name: "CursorColor", Type: "colors.Full", Doc: "the color used for the text field cursor (caret); this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"Edited", &gti.Field{Name: "Edited", Type: "bool", Doc: "true if the text has been edited relative to the original", Directives: gti.Directives{}}},
		{"EditTxt", &gti.Field{Name: "EditTxt", Type: "[]rune", Doc: "the live text string being edited, with latest modifications -- encoded as runes", Directives: gti.Directives{}}},
		{"MaxWidthReq", &gti.Field{Name: "MaxWidthReq", Type: "int", Doc: "maximum width that field will request, in characters, during GetSize process -- if 0 then is 50 -- ensures that large strings don't request super large values -- standard max-width can override", Directives: gti.Directives{}}},
		{"EffPos", &gti.Field{Name: "EffPos", Type: "mat32.Vec2", Doc: "effective position with any leading icon space added", Directives: gti.Directives{}}},
		{"EffSize", &gti.Field{Name: "EffSize", Type: "mat32.Vec2", Doc: "effective size, subtracting any leading and trailing icon space", Directives: gti.Directives{}}},
		{"StartPos", &gti.Field{Name: "StartPos", Type: "int", Doc: "starting display position in the string", Directives: gti.Directives{}}},
		{"EndPos", &gti.Field{Name: "EndPos", Type: "int", Doc: "ending display position in the string", Directives: gti.Directives{}}},
		{"CursorPos", &gti.Field{Name: "CursorPos", Type: "int", Doc: "current cursor position", Directives: gti.Directives{}}},
		{"CharWidth", &gti.Field{Name: "CharWidth", Type: "int", Doc: "approximate number of chars that can be displayed at any time -- computed from font size etc", Directives: gti.Directives{}}},
		{"SelectStart", &gti.Field{Name: "SelectStart", Type: "int", Doc: "starting position of selection in the string", Directives: gti.Directives{}}},
		{"SelectEnd", &gti.Field{Name: "SelectEnd", Type: "int", Doc: "ending position of selection in the string", Directives: gti.Directives{}}},
		{"SelectInit", &gti.Field{Name: "SelectInit", Type: "int", Doc: "initial selection position -- where it started", Directives: gti.Directives{}}},
		{"SelectMode", &gti.Field{Name: "SelectMode", Type: "bool", Doc: "if true, select text as cursor moves", Directives: gti.Directives{}}},
		{"RenderAll", &gti.Field{Name: "RenderAll", Type: "paint.Text", Doc: "render version of entire text, for sizing", Directives: gti.Directives{}}},
		{"RenderVis", &gti.Field{Name: "RenderVis", Type: "paint.Text", Doc: "render version of just visible text", Directives: gti.Directives{}}},
		{"FontHeight", &gti.Field{Name: "FontHeight", Type: "float32", Doc: "font height, cached during styling", Directives: gti.Directives{}}},
		{"BlinkOn", &gti.Field{Name: "BlinkOn", Type: "bool", Doc: "oscillates between on and off for blinking", Directives: gti.Directives{}}},
		{"CursorMu", &gti.Field{Name: "CursorMu", Type: "sync.Mutex", Doc: "[view: -] mutex for updating cursor between blinker and field", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TextField{},
})

// NewTextField adds a new [TextField] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTextField(par ki.Ki, name ...string) *TextField {
	return par.NewChild(TextFieldType, name...).(*TextField)
}

// KiType returns the [*gti.Type] of [TextField]
func (t *TextField) KiType() *gti.Type {
	return TextFieldType
}

// New returns a new [*TextField] value
func (t *TextField) New() ki.Ki {
	return &TextField{}
}

// TextFieldEmbedder is an interface that all types that embed TextField satisfy
type TextFieldEmbedder interface {
	AsTextField() *TextField
}

// AsTextField returns the given value as a value of type TextField if the type
// of the given value embeds TextField, or nil otherwise
func AsTextField(k ki.Ki) *TextField {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(TextFieldEmbedder); ok {
		return t.AsTextField()
	}
	return nil
}

// AsTextField satisfies the [TextFieldEmbedder] interface
func (t *TextField) AsTextField() *TextField {
	return t
}

// WidgetBaseType is the [gti.Type] for [WidgetBase]
var WidgetBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.WidgetBase",
	ShortName:  "gi.WidgetBase",
	IDName:     "widget-base",
	Doc:        "WidgetBase is the base type for all Widget Widget elements, which are\nmanaged by a containing Layout, and use all 5 rendering passes.  All\nelemental widgets must support the Inactive and Selected states in a\nreasonable way (Selected only essential when also Inactive), so they can\nfunction appropriately in a chooser (e.g., SliceView or TableView) -- this\nincludes toggling selection on left mouse press.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Class", &gti.Field{Name: "Class", Type: "string", Doc: "user-defined class name(s) used primarily for attaching CSS styles to different display elements -- multiple class names can be used to combine properties: use spaces to separate per css standard", Directives: gti.Directives{}}},
		{"CSS", &gti.Field{Name: "CSS", Type: "ki.Props", Doc: "cascading style sheet at this level -- these styles apply here and to everything below, until superceded -- use .class and #name Props elements to apply entire styles to given elements, and type for element type", Directives: gti.Directives{}}},
		{"CSSAgg", &gti.Field{Name: "CSSAgg", Type: "ki.Props", Doc: "[view: no-inline] aggregated css properties from all higher nodes down to me", Directives: gti.Directives{}}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", Doc: "raw original bounding box for the widget within its parent Scene -- used for computing ScBBox.  This is not updated by LayoutScroll, whereas ScBBox is", Directives: gti.Directives{}}},
		{"ObjBBox", &gti.Field{Name: "ObjBBox", Type: "image.Rectangle", Doc: "full object bbox -- this is BBox + LayoutScroll delta, but NOT intersected with parent's parBBox -- used for computing color gradients or other object-specific geometry computations", Directives: gti.Directives{}}},
		{"ScBBox", &gti.Field{Name: "ScBBox", Type: "image.Rectangle", Doc: "2D bounding box for region occupied within immediate parent Scene object that we render onto -- these are the pixels we draw into, filtered through parent bounding boxes -- used for render Bounds clipping", Directives: gti.Directives{}}},
		{"Tooltip", &gti.Field{Name: "Tooltip", Type: "string", Doc: "text for tooltip for this widget -- can use HTML formatting", Directives: gti.Directives{}}},
		{"Stylers", &gti.Field{Name: "Stylers", Type: "[]Styler", Doc: "a slice of stylers that are called in sequential descending order (so the first added styler is called last and thus overrides all other functions) to style the element; these should be set using AddStyles, which can be called by end-user and internal code", Directives: gti.Directives{}}},
		{"OverrideStyle", &gti.Field{Name: "OverrideStyle", Type: "bool", Doc: "override the computed styles and allow directly editing Style", Directives: gti.Directives{}}},
		{"Style", &gti.Field{Name: "Style", Type: "styles.Style", Doc: "styling settings for this widget -- set in SetApplyStyle during an initialization step, and when the structure changes; they are determined by, in increasing priority order, the default values, the ki node properties, and the StyleFunc (the recommended way to set styles is through the StyleFunc -- setting this field directly outside of that will have no effect unless OverrideStyle is on)", Directives: gti.Directives{}}},
		{"Listeners", &gti.Field{Name: "Listeners", Type: "events.Listeners", Doc: "Listeners are event listener functions for processing events on this widget.\ntype specific Listeners are added in OnInit when the widget is initialized.", Directives: gti.Directives{}}},
		{"Parts", &gti.Field{Name: "Parts", Type: "*Layout", Doc: "a separate tree of sub-widgets that implement discrete parts of a widget -- positions are always relative to the parent widget -- fully managed by the widget and not saved", Directives: gti.Directives{}}},
		{"LayState", &gti.Field{Name: "LayState", Type: "LayoutState", Doc: "all the layout state information for this widget", Directives: gti.Directives{}}},
		{"CtxtMenuFunc", &gti.Field{Name: "CtxtMenuFunc", Type: "CtxtMenuFunc", Doc: "[view: -] optional context menu function called by MakeContextMenu AFTER any native items are added -- this function can decide where to insert new elements -- typically add a separator to disambiguate", Directives: gti.Directives{}}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*Scene", Doc: "parent scene.  Only for use as a last resort when arg is not available -- otherwise always use the arg.  Set during Config.", Directives: gti.Directives{}}},
		{"StyMu", &gti.Field{Name: "StyMu", Type: "sync.RWMutex", Doc: "[view: -] mutex protecting the Style field", Directives: gti.Directives{}}},
		{"BBoxMu", &gti.Field{Name: "BBoxMu", Type: "sync.RWMutex", Doc: "[view: -] mutex protecting the BBox fields", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &WidgetBase{},
})

// NewWidgetBase adds a new [WidgetBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewWidgetBase(par ki.Ki, name ...string) *WidgetBase {
	return par.NewChild(WidgetBaseType, name...).(*WidgetBase)
}

// KiType returns the [*gti.Type] of [WidgetBase]
func (t *WidgetBase) KiType() *gti.Type {
	return WidgetBaseType
}

// New returns a new [*WidgetBase] value
func (t *WidgetBase) New() ki.Ki {
	return &WidgetBase{}
}
