// Code generated by "goki generate"; DO NOT EDIT.

package textview

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _BufSignalsValues = []BufSignals{0, 1, 2, 3, 4, 5}

// BufSignalsN is the highest valid value
// for type BufSignals, plus one.
const BufSignalsN BufSignals = 6

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BufSignalsNoOp() {
	var x [1]struct{}
	_ = x[BufDone-(0)]
	_ = x[BufNew-(1)]
	_ = x[BufInsert-(2)]
	_ = x[BufDelete-(3)]
	_ = x[BufMarkUpdt-(4)]
	_ = x[BufClosed-(5)]
}

var _BufSignalsNameToValueMap = map[string]BufSignals{
	`BufDone`:     0,
	`bufdone`:     0,
	`BufNew`:      1,
	`bufnew`:      1,
	`BufInsert`:   2,
	`bufinsert`:   2,
	`BufDelete`:   3,
	`bufdelete`:   3,
	`BufMarkUpdt`: 4,
	`bufmarkupdt`: 4,
	`BufClosed`:   5,
	`bufclosed`:   5,
}

var _BufSignalsDescMap = map[BufSignals]string{
	0: `BufDone means that editing was completed and applied to Txt field -- data is Txt bytes`,
	1: `BufNew signals that entirely new text is present -- all views update -- data is Txt bytes.`,
	2: `BufInsert signals that some text was inserted -- data is textbuf.Edit describing change -- the Buf always reflects the current state *after* the edit.`,
	3: `BufDelete signals that some text was deleted -- data is textbuf.Edit describing change -- the Buf always reflects the current state *after* the edit.`,
	4: `BufMarkUpdt signals that the Markup text has been updated -- this signal is typically sent from a separate goroutine so should be used with a mutex`,
	5: `BufClosed signals that the textbuf was closed`,
}

var _BufSignalsMap = map[BufSignals]string{
	0: `BufDone`,
	1: `BufNew`,
	2: `BufInsert`,
	3: `BufDelete`,
	4: `BufMarkUpdt`,
	5: `BufClosed`,
}

// String returns the string representation
// of this BufSignals value.
func (i BufSignals) String() string {
	if str, ok := _BufSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BufSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BufSignals) SetString(s string) error {
	if val, ok := _BufSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BufSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BufSignals")
}

// Int64 returns the BufSignals value as an int64.
func (i BufSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BufSignals value from an int64.
func (i *BufSignals) SetInt64(in int64) {
	*i = BufSignals(in)
}

// Desc returns the description of the BufSignals value.
func (i BufSignals) Desc() string {
	if str, ok := _BufSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BufSignalsValues returns all possible values
// for the type BufSignals.
func BufSignalsValues() []BufSignals {
	return _BufSignalsValues
}

// Values returns all possible values
// for the type BufSignals.
func (i BufSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BufSignalsValues))
	for i, d := range _BufSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BufSignals.
func (i BufSignals) IsValid() bool {
	_, ok := _BufSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BufSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BufSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _BufFlagsValues = []BufFlags{10, 11, 12, 13}

// BufFlagsN is the highest valid value
// for type BufFlags, plus one.
const BufFlagsN BufFlags = 14

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BufFlagsNoOp() {
	var x [1]struct{}
	_ = x[BufAutoSaving-(10)]
	_ = x[BufMarkingUp-(11)]
	_ = x[BufChanged-(12)]
	_ = x[BufFileModOk-(13)]
}

var _BufFlagsNameToValueMap = map[string]BufFlags{
	`BufAutoSaving`: 10,
	`bufautosaving`: 10,
	`BufMarkingUp`:  11,
	`bufmarkingup`:  11,
	`BufChanged`:    12,
	`bufchanged`:    12,
	`BufFileModOk`:  13,
	`buffilemodok`:  13,
}

var _BufFlagsDescMap = map[BufFlags]string{
	10: `BufAutoSaving is used in atomically safe way to protect autosaving`,
	11: `BufMarkingUp indicates current markup operation in progress -- don&#39;t redo`,
	12: `BufChanged indicates if the text has been changed (edited) relative to the original, since last save`,
	13: `BufFileModOk have already asked about fact that file has changed since being opened, user is ok`,
}

var _BufFlagsMap = map[BufFlags]string{
	10: `BufAutoSaving`,
	11: `BufMarkingUp`,
	12: `BufChanged`,
	13: `BufFileModOk`,
}

// String returns the string representation
// of this BufFlags value.
func (i BufFlags) String() string {
	str := ""
	for _, ie := range _BufFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this BufFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i BufFlags) BitIndexString() string {
	if str, ok := _BufFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BufFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BufFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the BufFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *BufFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _BufFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _BufFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type BufFlags")
		}
	}
	return nil
}

// Int64 returns the BufFlags value as an int64.
func (i BufFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BufFlags value from an int64.
func (i *BufFlags) SetInt64(in int64) {
	*i = BufFlags(in)
}

// Desc returns the description of the BufFlags value.
func (i BufFlags) Desc() string {
	if str, ok := _BufFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BufFlagsValues returns all possible values
// for the type BufFlags.
func BufFlagsValues() []BufFlags {
	return _BufFlagsValues
}

// Values returns all possible values
// for the type BufFlags.
func (i BufFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BufFlagsValues))
	for i, d := range _BufFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BufFlags.
func (i BufFlags) IsValid() bool {
	_, ok := _BufFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i BufFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *BufFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BufFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BufFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ViewSignalsValues = []ViewSignals{0, 1, 2, 3, 4}

// ViewSignalsN is the highest valid value
// for type ViewSignals, plus one.
const ViewSignalsN ViewSignals = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ViewSignalsNoOp() {
	var x [1]struct{}
	_ = x[ViewDone-(0)]
	_ = x[ViewSelected-(1)]
	_ = x[ViewCursorMoved-(2)]
	_ = x[ViewISearch-(3)]
	_ = x[ViewQReplace-(4)]
}

var _ViewSignalsNameToValueMap = map[string]ViewSignals{
	`ViewDone`:        0,
	`viewdone`:        0,
	`ViewSelected`:    1,
	`viewselected`:    1,
	`ViewCursorMoved`: 2,
	`viewcursormoved`: 2,
	`ViewISearch`:     3,
	`viewisearch`:     3,
	`ViewQReplace`:    4,
	`viewqreplace`:    4,
}

var _ViewSignalsDescMap = map[ViewSignals]string{
	0: `ViewDone signal indicates return was pressed and an edit was completed -- data is the text`,
	1: `ViewSelected signal indicates some text was selected (for Inactive state, selection is via WidgetSig)`,
	2: `ViewCursorMoved signal indicates cursor moved emitted for every cursor movement -- e.g., for displaying cursor pos`,
	3: `ViewISearch is emitted for every update of interactive search process -- see ISearch.* members for current state`,
	4: `ViewQReplace is emitted for every update of query-replace process -- see QReplace.* members for current state`,
}

var _ViewSignalsMap = map[ViewSignals]string{
	0: `ViewDone`,
	1: `ViewSelected`,
	2: `ViewCursorMoved`,
	3: `ViewISearch`,
	4: `ViewQReplace`,
}

// String returns the string representation
// of this ViewSignals value.
func (i ViewSignals) String() string {
	if str, ok := _ViewSignalsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ViewSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ViewSignals) SetString(s string) error {
	if val, ok := _ViewSignalsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ViewSignalsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type ViewSignals")
}

// Int64 returns the ViewSignals value as an int64.
func (i ViewSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ViewSignals value from an int64.
func (i *ViewSignals) SetInt64(in int64) {
	*i = ViewSignals(in)
}

// Desc returns the description of the ViewSignals value.
func (i ViewSignals) Desc() string {
	if str, ok := _ViewSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ViewSignalsValues returns all possible values
// for the type ViewSignals.
func ViewSignalsValues() []ViewSignals {
	return _ViewSignalsValues
}

// Values returns all possible values
// for the type ViewSignals.
func (i ViewSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ViewSignalsValues))
	for i, d := range _ViewSignalsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ViewSignals.
func (i ViewSignals) IsValid() bool {
	_, ok := _ViewSignalsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ViewSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ViewSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ViewStatesValues = []ViewStates{0, 1, 2, 3, 4}

// ViewStatesN is the highest valid value
// for type ViewStates, plus one.
const ViewStatesN ViewStates = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ViewStatesNoOp() {
	var x [1]struct{}
	_ = x[ViewActive-(0)]
	_ = x[ViewFocus-(1)]
	_ = x[ViewInactive-(2)]
	_ = x[ViewSel-(3)]
	_ = x[ViewHighlight-(4)]
}

var _ViewStatesNameToValueMap = map[string]ViewStates{
	`ViewActive`:    0,
	`viewactive`:    0,
	`ViewFocus`:     1,
	`viewfocus`:     1,
	`ViewInactive`:  2,
	`viewinactive`:  2,
	`ViewSel`:       3,
	`viewsel`:       3,
	`ViewHighlight`: 4,
	`viewhighlight`: 4,
}

var _ViewStatesDescMap = map[ViewStates]string{
	0: `ViewActive is the normal state -- there but not being interacted with`,
	1: `ViewFocus states means textvieww is the focus -- will respond to keyboard input`,
	2: `ViewInactive means the textview is inactive -- not editable`,
	3: `ViewSel means the text region is selected`,
	4: `ViewHighlight means the text region is highlighted`,
}

var _ViewStatesMap = map[ViewStates]string{
	0: `ViewActive`,
	1: `ViewFocus`,
	2: `ViewInactive`,
	3: `ViewSel`,
	4: `ViewHighlight`,
}

// String returns the string representation
// of this ViewStates value.
func (i ViewStates) String() string {
	if str, ok := _ViewStatesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ViewStates value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ViewStates) SetString(s string) error {
	if val, ok := _ViewStatesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ViewStatesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type ViewStates")
}

// Int64 returns the ViewStates value as an int64.
func (i ViewStates) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ViewStates value from an int64.
func (i *ViewStates) SetInt64(in int64) {
	*i = ViewStates(in)
}

// Desc returns the description of the ViewStates value.
func (i ViewStates) Desc() string {
	if str, ok := _ViewStatesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ViewStatesValues returns all possible values
// for the type ViewStates.
func ViewStatesValues() []ViewStates {
	return _ViewStatesValues
}

// Values returns all possible values
// for the type ViewStates.
func (i ViewStates) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ViewStatesValues))
	for i, d := range _ViewStatesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ViewStates.
func (i ViewStates) IsValid() bool {
	_, ok := _ViewStatesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ViewStates) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ViewStates) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _ViewFlagsValues = []ViewFlags{10, 11, 12, 13, 14, 15, 16}

// ViewFlagsN is the highest valid value
// for type ViewFlags, plus one.
const ViewFlagsN ViewFlags = 17

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ViewFlagsNoOp() {
	var x [1]struct{}
	_ = x[ViewNeedsRefresh-(10)]
	_ = x[ViewInReLayout-(11)]
	_ = x[ViewRenderScrolls-(12)]
	_ = x[ViewFocusActive-(13)]
	_ = x[ViewHasLineNos-(14)]
	_ = x[ViewLastWasTabAI-(15)]
	_ = x[ViewLastWasUndo-(16)]
}

var _ViewFlagsNameToValueMap = map[string]ViewFlags{
	`ViewNeedsRefresh`:  10,
	`viewneedsrefresh`:  10,
	`ViewInReLayout`:    11,
	`viewinrelayout`:    11,
	`ViewRenderScrolls`: 12,
	`viewrenderscrolls`: 12,
	`ViewFocusActive`:   13,
	`viewfocusactive`:   13,
	`ViewHasLineNos`:    14,
	`viewhaslinenos`:    14,
	`ViewLastWasTabAI`:  15,
	`viewlastwastabai`:  15,
	`ViewLastWasUndo`:   16,
	`viewlastwasundo`:   16,
}

var _ViewFlagsDescMap = map[ViewFlags]string{
	10: `ViewNeedsRefresh indicates when refresh is required`,
	11: `ViewInReLayout indicates that we are currently resizing ourselves via parent layout`,
	12: `ViewRenderScrolls indicates that parent layout scrollbars need to be re-rendered at next rerender`,
	13: `ViewFocusActive is set if the keyboard focus is active -- when we lose active focus we apply changes`,
	14: `ViewHasLineNos indicates that this view has line numbers (per Buf option)`,
	15: `ViewLastWasTabAI indicates that last key was a Tab auto-indent`,
	16: `ViewLastWasUndo indicates that last key was an undo`,
}

var _ViewFlagsMap = map[ViewFlags]string{
	10: `ViewNeedsRefresh`,
	11: `ViewInReLayout`,
	12: `ViewRenderScrolls`,
	13: `ViewFocusActive`,
	14: `ViewHasLineNos`,
	15: `ViewLastWasTabAI`,
	16: `ViewLastWasUndo`,
}

// String returns the string representation
// of this ViewFlags value.
func (i ViewFlags) String() string {
	str := ""
	for _, ie := range _ViewFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this ViewFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i ViewFlags) BitIndexString() string {
	if str, ok := _ViewFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the ViewFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *ViewFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the ViewFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *ViewFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _ViewFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _ViewFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type ViewFlags")
		}
	}
	return nil
}

// Int64 returns the ViewFlags value as an int64.
func (i ViewFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the ViewFlags value from an int64.
func (i *ViewFlags) SetInt64(in int64) {
	*i = ViewFlags(in)
}

// Desc returns the description of the ViewFlags value.
func (i ViewFlags) Desc() string {
	if str, ok := _ViewFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ViewFlagsValues returns all possible values
// for the type ViewFlags.
func ViewFlagsValues() []ViewFlags {
	return _ViewFlagsValues
}

// Values returns all possible values
// for the type ViewFlags.
func (i ViewFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ViewFlagsValues))
	for i, d := range _ViewFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type ViewFlags.
func (i ViewFlags) IsValid() bool {
	_, ok := _ViewFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i ViewFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *ViewFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ViewFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ViewFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
