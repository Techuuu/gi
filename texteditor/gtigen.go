// Code generated by "goki generate"; DO NOT EDIT.

package texteditor

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

// TwinViewsType is the [gti.Type] for [TwinViews]
var TwinViewsType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/textview.TwinViews",
	ShortName:  "textview.TwinViews",
	IDName:     "twin-views",
	Doc:        "TwinViews presents two side-by-side View windows in Splits\nthat scroll in sync with each other.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"BufA", &gti.Field{Name: "BufA", Type: "*Buf", Doc: "textbuf for A", Directives: gti.Directives{}}},
		{"BufB", &gti.Field{Name: "BufB", Type: "*Buf", Doc: "textbuf for B", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Splits", &gti.Field{Name: "Splits", Type: "gi.Splits", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TwinEditors{},
})

// NewTwinViews adds a new [TwinViews] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTwinViews(par ki.Ki, name ...string) *TwinEditors {
	return par.NewChild(TwinViewsType, name...).(*TwinEditors)
}

// KiType returns the [*gti.Type] of [TwinViews]
func (t *TwinEditors) KiType() *gti.Type {
	return TwinViewsType
}

// New returns a new [*TwinViews] value
func (t *TwinEditors) New() ki.Ki {
	return &TwinEditors{}
}

// ViewType is the [gti.Type] for [View]
var ViewType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/textview.View",
	ShortName: "textview.View",
	IDName:    "view",
	Doc:       "View is a widget for editing multiple lines of text (as compared to\nTextField for a single line).  The View is driven by a Buf buffer which\ncontains all the text, and manages all the edits, sending update signals\nout to the views -- multiple views can be attached to a given buffer.  All\nupdating in the View should be within a single goroutine -- it would\nrequire extensive protections throughout code otherwise.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Buf", &gti.Field{Name: "Buf", Type: "*Buf", Doc: "the text buffer that we're editing", Directives: gti.Directives{}}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", Doc: "text that is displayed when the field is empty, in a lower-contrast manner", Directives: gti.Directives{}}},
		{"CursorWidth", &gti.Field{Name: "CursorWidth", Type: "units.Value", Doc: "width of cursor -- set from cursor-width property (inherited)", Directives: gti.Directives{}}},
		{"LineNumberColor", &gti.Field{Name: "LineNumberColor", Type: "colors.Full", Doc: "the color used for the side bar containing the line numbers; this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"SelectColor", &gti.Field{Name: "SelectColor", Type: "colors.Full", Doc: "the color used for the user text selection background color; this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"HighlightColor", &gti.Field{Name: "HighlightColor", Type: "colors.Full", Doc: "the color used for the text highlight background color (like in find); this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"CursorColor", &gti.Field{Name: "CursorColor", Type: "colors.Full", Doc: "the color used for the text field cursor (caret); this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"NLines", &gti.Field{Name: "NLines", Type: "int", Doc: "number of lines in the view -- sync'd with the Buf after edits, but always reflects storage size of Renders etc", Directives: gti.Directives{}}},
		{"Renders", &gti.Field{Name: "Renders", Type: "[]paint.Text", Doc: "renders of the text lines, with one render per line (each line could visibly wrap-around, so these are logical lines, not display lines)", Directives: gti.Directives{}}},
		{"Offs", &gti.Field{Name: "Offs", Type: "[]float32", Doc: "starting render offsets for top of each line", Directives: gti.Directives{}}},
		{"LineNoDigs", &gti.Field{Name: "LineNoDigs", Type: "int", Doc: "number of line number digits needed", Directives: gti.Directives{}}},
		{"LineNoOff", &gti.Field{Name: "LineNoOff", Type: "float32", Doc: "horizontal offset for start of text after line numbers", Directives: gti.Directives{}}},
		{"LineNoRender", &gti.Field{Name: "LineNoRender", Type: "paint.Text", Doc: "render for line numbers", Directives: gti.Directives{}}},
		{"CursorPos", &gti.Field{Name: "CursorPos", Type: "lex.Pos", Doc: "current cursor position", Directives: gti.Directives{}}},
		{"CursorCol", &gti.Field{Name: "CursorCol", Type: "int", Doc: "desired cursor column -- where the cursor was last when moved using left / right arrows -- used when doing up / down to not always go to short line columns", Directives: gti.Directives{}}},
		{"ScrollToCursorOnRender", &gti.Field{Name: "ScrollToCursorOnRender", Type: "bool", Doc: "if true, scroll screen to cursor on next render", Directives: gti.Directives{}}},
		{"ScrollToCursorPos", &gti.Field{Name: "ScrollToCursorPos", Type: "lex.Pos", Doc: "cursor position to scroll to", Directives: gti.Directives{}}},
		{"PosHistIdx", &gti.Field{Name: "PosHistIdx", Type: "int", Doc: "current index within PosHistory", Directives: gti.Directives{}}},
		{"SelectStart", &gti.Field{Name: "SelectStart", Type: "lex.Pos", Doc: "starting point for selection -- will either be the start or end of selected region depending on subsequent selection.", Directives: gti.Directives{}}},
		{"SelectReg", &gti.Field{Name: "SelectReg", Type: "textbuf.Region", Doc: "current selection region", Directives: gti.Directives{}}},
		{"PrevSelectReg", &gti.Field{Name: "PrevSelectReg", Type: "textbuf.Region", Doc: "previous selection region, that was actually rendered -- needed to update render", Directives: gti.Directives{}}},
		{"Highlights", &gti.Field{Name: "Highlights", Type: "[]textbuf.Region", Doc: "highlighted regions, e.g., for search results", Directives: gti.Directives{}}},
		{"Scopelights", &gti.Field{Name: "Scopelights", Type: "[]textbuf.Region", Doc: "highlighted regions, specific to scope markers", Directives: gti.Directives{}}},
		{"SelectMode", &gti.Field{Name: "SelectMode", Type: "bool", Doc: "if true, select text as cursor moves", Directives: gti.Directives{}}},
		{"ForceComplete", &gti.Field{Name: "ForceComplete", Type: "bool", Doc: "if true, complete regardless of any disqualifying reasons", Directives: gti.Directives{}}},
		{"ISearch", &gti.Field{Name: "ISearch", Type: "ISearch", Doc: "interactive search data", Directives: gti.Directives{}}},
		{"QReplace", &gti.Field{Name: "QReplace", Type: "QReplace", Doc: "query replace data", Directives: gti.Directives{}}},
		{"FontHeight", &gti.Field{Name: "FontHeight", Type: "float32", Doc: "font height, cached during styling", Directives: gti.Directives{}}},
		{"LineHeight", &gti.Field{Name: "LineHeight", Type: "float32", Doc: "line height, cached during styling", Directives: gti.Directives{}}},
		{"NLinesChars", &gti.Field{Name: "NLinesChars", Type: "image.Point", Doc: "height in lines and width in chars of the visible area", Directives: gti.Directives{}}},
		{"LinesSize", &gti.Field{Name: "LinesSize", Type: "mat32.Vec2", Doc: "total size of all lines as rendered", Directives: gti.Directives{}}},
		{"TotalSize", &gti.Field{Name: "TotalSize", Type: "mat32.Vec2", Doc: "TotalSize = LinesSize plus extra space and line numbers etc", Directives: gti.Directives{}}},
		{"LineLayoutSize", &gti.Field{Name: "LineLayoutSize", Type: "mat32.Vec2", Doc: "LineLayoutSize is LayState.Alloc.Size subtracting\nextra space and line numbers -- this is what\nLayoutStdLR sees for laying out each line", Directives: gti.Directives{}}},
		{"BlinkOn", &gti.Field{Name: "BlinkOn", Type: "bool", Doc: "oscillates between on and off for blinking", Directives: gti.Directives{}}},
		{"CursorMu", &gti.Field{Name: "CursorMu", Type: "sync.Mutex", Doc: "mutex protecting cursor rendering -- shared between blink and main code", Directives: gti.Directives{}}},
		{"HasLinks", &gti.Field{Name: "HasLinks", Type: "bool", Doc: "at least one of the renders has links -- determines if we set the cursor for hand movements", Directives: gti.Directives{}}},
		{"lastRecenter", &gti.Field{Name: "lastRecenter", Type: "int", Doc: "", Directives: gti.Directives{}}},
		{"lastAutoInsert", &gti.Field{Name: "lastAutoInsert", Type: "rune", Doc: "", Directives: gti.Directives{}}},
		{"lastFilename", &gti.Field{Name: "lastFilename", Type: "gi.FileName", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "gi.Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Editor{},
})

// NewView adds a new [View] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewView(par ki.Ki, name ...string) *Editor {
	return par.NewChild(ViewType, name...).(*Editor)
}

// KiType returns the [*gti.Type] of [View]
func (t *Editor) KiType() *gti.Type {
	return ViewType
}

// New returns a new [*View] value
func (t *Editor) New() ki.Ki {
	return &Editor{}
}

// ViewEmbedder is an interface that all types that embed View satisfy
type ViewEmbedder interface {
	AsView() *Editor
}

// AsView returns the given value as a value of type View if the type
// of the given value embeds View, or nil otherwise
func AsView(k ki.Ki) *Editor {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(ViewEmbedder); ok {
		return t.AsView()
	}
	return nil
}

// AsView satisfies the [ViewEmbedder] interface
func (t *Editor) AsView() *Editor {
	return t
}
