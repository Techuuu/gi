// Code generated by "goki generate"; DO NOT EDIT.

package filetree

import (
	"sync"
	"time"

	"goki.dev/gi/v2/gi"
	"goki.dev/gi/v2/giv"
	"goki.dev/girl/units"
	"goki.dev/gti"
	"goki.dev/icons"
	"goki.dev/ki/v2"
	"goki.dev/mat32/v2"
	"goki.dev/ordmap"
	"gopkg.in/fsnotify.v1"
)

// NodeType is the [gti.Type] for [Node]
var NodeType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/filetree.Node",
	ShortName: "filetree.Node",
	IDName:    "node",
	Doc:       "Node represents a file in the file system, as a TreeView node.\nThe name of the node is the name of the file.\nFolders have children containing further nodes.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FPath", &gti.Field{Name: "FPath", Type: "goki.dev/gi/v2/gi.FileName", LocalType: "gi.FileName", Doc: "full path to this file", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\" json:\"-\" xml:\"-\" copy:\"-\""}},
		{"Info", &gti.Field{Name: "Info", Type: "goki.dev/pi/v2/filecat.FileInfo", LocalType: "filecat.FileInfo", Doc: "full standard file info about this file", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\" json:\"-\" xml:\"-\" copy:\"-\""}},
		{"Buf", &gti.Field{Name: "Buf", Type: "*goki.dev/gi/v2/texteditor.Buf", LocalType: "*texteditor.Buf", Doc: "file buffer for editing this file", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\" json:\"-\" xml:\"-\" copy:\"-\""}},
		{"FRoot", &gti.Field{Name: "FRoot", Type: "*goki.dev/gi/v2/filetree.Tree", LocalType: "*Tree", Doc: "root of the tree -- has global state", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\" json:\"-\" xml:\"-\" copy:\"-\""}},
		{"DirRepo", &gti.Field{Name: "DirRepo", Type: "goki.dev/vci/v2.Repo", LocalType: "vci.Repo", Doc: "version control system repository for this directory,\nonly non-nil if this is the highest-level directory in the tree under vcs control", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\" json:\"-\" xml:\"-\" copy:\"-\""}},
		{"RepoFiles", &gti.Field{Name: "RepoFiles", Type: "goki.dev/vci/v2.Files", LocalType: "vci.Files", Doc: "version control system repository file status -- only valid during ReadDir", Directives: gti.Directives{}, Tag: "edit:\"-\" set:\"-\" json:\"-\" xml:\"-\" copy:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TreeView", &gti.Field{Name: "TreeView", Type: "goki.dev/gi/v2/giv.TreeView", LocalType: "giv.TreeView", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Node{},
})

// NewNode adds a new [Node] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewNode(par ki.Ki, name ...string) *Node {
	return par.NewChild(NodeType, name...).(*Node)
}

// KiType returns the [*gti.Type] of [Node]
func (t *Node) KiType() *gti.Type {
	return NodeType
}

// New returns a new [*Node] value
func (t *Node) New() ki.Ki {
	return &Node{}
}

// NodeEmbedder is an interface that all types that embed Node satisfy
type NodeEmbedder interface {
	AsNode() *Node
}

// AsNode returns the given value as a value of type Node if the type
// of the given value embeds Node, or nil otherwise
func AsNode(k ki.Ki) *Node {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(NodeEmbedder); ok {
		return t.AsNode()
	}
	return nil
}

// AsNode satisfies the [NodeEmbedder] interface
func (t *Node) AsNode() *Node {
	return t
}

// SetTooltip sets the [Node.Tooltip]
func (t *Node) SetTooltip(v string) *Node {
	t.Tooltip = v
	return t
}

// SetClass sets the [Node.Class]
func (t *Node) SetClass(v string) *Node {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Node.CustomContextMenu]
func (t *Node) SetCustomContextMenu(v func(m *gi.Scene)) *Node {
	t.CustomContextMenu = v
	return t
}

// SetIcon sets the [Node.Icon]
func (t *Node) SetIcon(v icons.Icon) *Node {
	t.Icon = v
	return t
}

// SetIndent sets the [Node.Indent]
func (t *Node) SetIndent(v units.Value) *Node {
	t.Indent = v
	return t
}

// SetOpenDepth sets the [Node.OpenDepth]
func (t *Node) SetOpenDepth(v int) *Node {
	t.OpenDepth = v
	return t
}

// SetViewIdx sets the [Node.ViewIdx]
func (t *Node) SetViewIdx(v int) *Node {
	t.ViewIdx = v
	return t
}

// SetWidgetSize sets the [Node.WidgetSize]
func (t *Node) SetWidgetSize(v mat32.Vec2) *Node {
	t.WidgetSize = v
	return t
}

// SetRootView sets the [Node.RootView]
func (t *Node) SetRootView(v *giv.TreeView) *Node {
	t.RootView = v
	return t
}

// SetSelectedNodes sets the [Node.SelectedNodes]
func (t *Node) SetSelectedNodes(v []*giv.TreeView) *Node {
	t.SelectedNodes = v
	return t
}

// TreeType is the [gti.Type] for [Tree]
var TreeType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/filetree.Tree",
	ShortName:  "filetree.Tree",
	IDName:     "tree",
	Doc:        "Tree is the root of a tree representing files in a given directory\n(and subdirectories thereof), and has some overall management state for how to\nview things.  The Tree can be viewed by a TreeView to provide a GUI\ninterface into it.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ExtFiles", &gti.Field{Name: "ExtFiles", Type: "[]string", LocalType: "[]string", Doc: "external files outside the root path of the tree -- abs paths are stored -- these are shown in the first sub-node if present -- use AddExtFile to add and update", Directives: gti.Directives{}, Tag: ""}},
		{"Dirs", &gti.Field{Name: "Dirs", Type: "goki.dev/gi/v2/filetree.DirFlagMap", LocalType: "DirFlagMap", Doc: "records state of directories within the tree (encoded using paths relative to root),\ne.g., open (have been opened by the user) -- can persist this to restore prior view of a tree", Directives: gti.Directives{}, Tag: ""}},
		{"DirsOnTop", &gti.Field{Name: "DirsOnTop", Type: "bool", LocalType: "bool", Doc: "if true, then all directories are placed at the top of the tree view\notherwise everything is mixed", Directives: gti.Directives{}, Tag: ""}},
		{"NodeType", &gti.Field{Name: "NodeType", Type: "*goki.dev/gti.Type", LocalType: "*gti.Type", Doc: "type of node to create -- defaults to giv.Node but can use custom node types", Directives: gti.Directives{}, Tag: "view:\"-\" json:\"-\" xml:\"-\""}},
		{"InOpenAll", &gti.Field{Name: "InOpenAll", Type: "bool", LocalType: "bool", Doc: "if true, we are in midst of an OpenAll call -- nodes should open all dirs", Directives: gti.Directives{}, Tag: ""}},
		{"Watcher", &gti.Field{Name: "Watcher", Type: "*gopkg.in/fsnotify.v1.Watcher", LocalType: "*fsnotify.Watcher", Doc: "change notify for all dirs", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"DoneWatcher", &gti.Field{Name: "DoneWatcher", Type: "chan bool", LocalType: "chan bool", Doc: "channel to close watcher watcher", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"WatchedPaths", &gti.Field{Name: "WatchedPaths", Type: "map[string]bool", LocalType: "map[string]bool", Doc: "map of paths that have been added to watcher -- only active if bool = true", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"LastWatchUpdt", &gti.Field{Name: "LastWatchUpdt", Type: "string", LocalType: "string", Doc: "last path updated by watcher", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"LastWatchTime", &gti.Field{Name: "LastWatchTime", Type: "time.Time", LocalType: "time.Time", Doc: "timestamp of last update", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"UpdtMu", &gti.Field{Name: "UpdtMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "Update mutex", Directives: gti.Directives{}, Tag: "view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/gi/v2/filetree.Node", LocalType: "Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Tree{},
})

// NewTree adds a new [Tree] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTree(par ki.Ki, name ...string) *Tree {
	return par.NewChild(TreeType, name...).(*Tree)
}

// KiType returns the [*gti.Type] of [Tree]
func (t *Tree) KiType() *gti.Type {
	return TreeType
}

// New returns a new [*Tree] value
func (t *Tree) New() ki.Ki {
	return &Tree{}
}

// SetExtFiles sets the [Tree.ExtFiles]:
// external files outside the root path of the tree -- abs paths are stored -- these are shown in the first sub-node if present -- use AddExtFile to add and update
func (t *Tree) SetExtFiles(v []string) *Tree {
	t.ExtFiles = v
	return t
}

// SetDirs sets the [Tree.Dirs]:
// records state of directories within the tree (encoded using paths relative to root),
// e.g., open (have been opened by the user) -- can persist this to restore prior view of a tree
func (t *Tree) SetDirs(v DirFlagMap) *Tree {
	t.Dirs = v
	return t
}

// SetDirsOnTop sets the [Tree.DirsOnTop]:
// if true, then all directories are placed at the top of the tree view
// otherwise everything is mixed
func (t *Tree) SetDirsOnTop(v bool) *Tree {
	t.DirsOnTop = v
	return t
}

// SetNodeType sets the [Tree.NodeType]:
// type of node to create -- defaults to giv.Node but can use custom node types
func (t *Tree) SetNodeType(v *gti.Type) *Tree {
	t.NodeType = v
	return t
}

// SetInOpenAll sets the [Tree.InOpenAll]:
// if true, we are in midst of an OpenAll call -- nodes should open all dirs
func (t *Tree) SetInOpenAll(v bool) *Tree {
	t.InOpenAll = v
	return t
}

// SetWatcher sets the [Tree.Watcher]:
// change notify for all dirs
func (t *Tree) SetWatcher(v *fsnotify.Watcher) *Tree {
	t.Watcher = v
	return t
}

// SetDoneWatcher sets the [Tree.DoneWatcher]:
// channel to close watcher watcher
func (t *Tree) SetDoneWatcher(v chan bool) *Tree {
	t.DoneWatcher = v
	return t
}

// SetWatchedPaths sets the [Tree.WatchedPaths]:
// map of paths that have been added to watcher -- only active if bool = true
func (t *Tree) SetWatchedPaths(v map[string]bool) *Tree {
	t.WatchedPaths = v
	return t
}

// SetLastWatchUpdt sets the [Tree.LastWatchUpdt]:
// last path updated by watcher
func (t *Tree) SetLastWatchUpdt(v string) *Tree {
	t.LastWatchUpdt = v
	return t
}

// SetLastWatchTime sets the [Tree.LastWatchTime]:
// timestamp of last update
func (t *Tree) SetLastWatchTime(v time.Time) *Tree {
	t.LastWatchTime = v
	return t
}

// SetUpdtMu sets the [Tree.UpdtMu]:
// Update mutex
func (t *Tree) SetUpdtMu(v sync.Mutex) *Tree {
	t.UpdtMu = v
	return t
}

// SetTooltip sets the [Tree.Tooltip]
func (t *Tree) SetTooltip(v string) *Tree {
	t.Tooltip = v
	return t
}

// SetClass sets the [Tree.Class]
func (t *Tree) SetClass(v string) *Tree {
	t.Class = v
	return t
}

// SetCustomContextMenu sets the [Tree.CustomContextMenu]
func (t *Tree) SetCustomContextMenu(v func(m *gi.Scene)) *Tree {
	t.CustomContextMenu = v
	return t
}

// SetIcon sets the [Tree.Icon]
func (t *Tree) SetIcon(v icons.Icon) *Tree {
	t.Icon = v
	return t
}

// SetIndent sets the [Tree.Indent]
func (t *Tree) SetIndent(v units.Value) *Tree {
	t.Indent = v
	return t
}

// SetOpenDepth sets the [Tree.OpenDepth]
func (t *Tree) SetOpenDepth(v int) *Tree {
	t.OpenDepth = v
	return t
}

// SetViewIdx sets the [Tree.ViewIdx]
func (t *Tree) SetViewIdx(v int) *Tree {
	t.ViewIdx = v
	return t
}

// SetWidgetSize sets the [Tree.WidgetSize]
func (t *Tree) SetWidgetSize(v mat32.Vec2) *Tree {
	t.WidgetSize = v
	return t
}

// SetRootView sets the [Tree.RootView]
func (t *Tree) SetRootView(v *giv.TreeView) *Tree {
	t.RootView = v
	return t
}

// SetSelectedNodes sets the [Tree.SelectedNodes]
func (t *Tree) SetSelectedNodes(v []*giv.TreeView) *Tree {
	t.SelectedNodes = v
	return t
}
