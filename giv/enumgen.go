// Code generated by "goki generate"; DO NOT EDIT.

package giv

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
	"goki.dev/ki/v2"
)

var _FileNodeFlagsValues = []FileNodeFlags{7, 8}

// FileNodeFlagsN is the highest valid value
// for type FileNodeFlags, plus one.
const FileNodeFlagsN FileNodeFlags = 9

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FileNodeFlagsNoOp() {
	var x [1]struct{}
	_ = x[FileNodeOpen-(7)]
	_ = x[FileNodeSymLink-(8)]
}

var _FileNodeFlagsNameToValueMap = map[string]FileNodeFlags{
	`Open`:    7,
	`open`:    7,
	`SymLink`: 8,
	`symlink`: 8,
}

var _FileNodeFlagsDescMap = map[FileNodeFlags]string{
	7: `FileNodeOpen means file is open -- for directories, this means that sub-files should be / have been loaded -- for files, means that they have been opened e.g., for editing`,
	8: `FileNodeSymLink indicates that file is a symbolic link -- file info is all for the target of the symlink`,
}

var _FileNodeFlagsMap = map[FileNodeFlags]string{
	7: `Open`,
	8: `SymLink`,
}

// String returns the string representation
// of this FileNodeFlags value.
func (i FileNodeFlags) String() string {
	str := ""
	for _, ie := range ki.FlagsValues() {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	for _, ie := range _FileNodeFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this FileNodeFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i FileNodeFlags) BitIndexString() string {
	if str, ok := _FileNodeFlagsMap[i]; ok {
		return str
	}
	return ki.Flags(i).BitIndexString()
}

// SetString sets the FileNodeFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FileNodeFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the FileNodeFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *FileNodeFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _FileNodeFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _FileNodeFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			err := (*ki.Flags)(i).SetStringOr(flg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// Int64 returns the FileNodeFlags value as an int64.
func (i FileNodeFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FileNodeFlags value from an int64.
func (i *FileNodeFlags) SetInt64(in int64) {
	*i = FileNodeFlags(in)
}

// Desc returns the description of the FileNodeFlags value.
func (i FileNodeFlags) Desc() string {
	if str, ok := _FileNodeFlagsDescMap[i]; ok {
		return str
	}
	return ki.Flags(i).Desc()
}

// FileNodeFlagsValues returns all possible values
// for the type FileNodeFlags.
func FileNodeFlagsValues() []FileNodeFlags {
	es := ki.FlagsValues()
	res := make([]FileNodeFlags, len(es))
	for i, e := range es {
		res[i] = FileNodeFlags(e)
	}
	res = append(res, _FileNodeFlagsValues...)
	return res
}

// Values returns all possible values
// for the type FileNodeFlags.
func (i FileNodeFlags) Values() []enums.Enum {
	es := ki.FlagsValues()
	les := len(es)
	res := make([]enums.Enum, les+len(_FileNodeFlagsValues))
	for i, d := range es {
		res[i] = d
	}
	for i, d := range _FileNodeFlagsValues {
		res[i+les] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FileNodeFlags.
func (i FileNodeFlags) IsValid() bool {
	_, ok := _FileNodeFlagsMap[i]
	if !ok {
		return ki.Flags(i).IsValid()
	}
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i FileNodeFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *FileNodeFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FileNodeFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FileNodeFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _DirFlagsValues = []DirFlags{0, 1, 2, 3}

// DirFlagsN is the highest valid value
// for type DirFlags, plus one.
const DirFlagsN DirFlags = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _DirFlagsNoOp() {
	var x [1]struct{}
	_ = x[DirMark-(0)]
	_ = x[DirIsOpen-(1)]
	_ = x[DirSortByName-(2)]
	_ = x[DirSortByModTime-(3)]
}

var _DirFlagsNameToValueMap = map[string]DirFlags{
	`Mark`:          0,
	`mark`:          0,
	`IsOpen`:        1,
	`isopen`:        1,
	`SortByName`:    2,
	`sortbyname`:    2,
	`SortByModTime`: 3,
	`sortbymodtime`: 3,
}

var _DirFlagsDescMap = map[DirFlags]string{
	0: `DirMark means directory is marked -- unmarked entries are deleted post-update`,
	1: `DirIsOpen means directory is open -- else closed`,
	2: `DirSortByName means sort the directory entries by name. this is mutex with other sorts -- keeping option open for non-binary sort choices.`,
	3: `DirSortByModTime means sort the directory entries by modification time`,
}

var _DirFlagsMap = map[DirFlags]string{
	0: `Mark`,
	1: `IsOpen`,
	2: `SortByName`,
	3: `SortByModTime`,
}

// String returns the string representation
// of this DirFlags value.
func (i DirFlags) String() string {
	str := ""
	for _, ie := range _DirFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this DirFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i DirFlags) BitIndexString() string {
	if str, ok := _DirFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the DirFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *DirFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the DirFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *DirFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _DirFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _DirFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type DirFlags")
		}
	}
	return nil
}

// Int64 returns the DirFlags value as an int64.
func (i DirFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the DirFlags value from an int64.
func (i *DirFlags) SetInt64(in int64) {
	*i = DirFlags(in)
}

// Desc returns the description of the DirFlags value.
func (i DirFlags) Desc() string {
	if str, ok := _DirFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// DirFlagsValues returns all possible values
// for the type DirFlags.
func DirFlagsValues() []DirFlags {
	return _DirFlagsValues
}

// Values returns all possible values
// for the type DirFlags.
func (i DirFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_DirFlagsValues))
	for i, d := range _DirFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type DirFlags.
func (i DirFlags) IsValid() bool {
	_, ok := _DirFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i DirFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *DirFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DirFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DirFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _SliceViewFlagsValues = []SliceViewFlags{9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}

// SliceViewFlagsN is the highest valid value
// for type SliceViewFlags, plus one.
const SliceViewFlagsN SliceViewFlags = 20

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SliceViewFlagsNoOp() {
	var x [1]struct{}
	_ = x[SliceViewNoAdd-(9)]
	_ = x[SliceViewNoDelete-(10)]
	_ = x[SliceViewShowViewCtxtMenu-(11)]
	_ = x[SliceViewIsArray-(12)]
	_ = x[SliceViewShowIndex-(13)]
	_ = x[SliceViewShowToolbar-(14)]
	_ = x[SliceViewInactKeyNav-(15)]
	_ = x[SliceViewSelectMode-(16)]
	_ = x[SliceViewInactMultiSel-(17)]
	_ = x[SliceViewInFocusGrab-(18)]
	_ = x[SliceViewInFullRebuild-(19)]
}

var _SliceViewFlagsNameToValueMap = map[string]SliceViewFlags{
	`NoAdd`:            9,
	`noadd`:            9,
	`NoDelete`:         10,
	`nodelete`:         10,
	`ShowViewCtxtMenu`: 11,
	`showviewctxtmenu`: 11,
	`IsArray`:          12,
	`isarray`:          12,
	`ShowIndex`:        13,
	`showindex`:        13,
	`ShowToolbar`:      14,
	`showtoolbar`:      14,
	`InactKeyNav`:      15,
	`inactkeynav`:      15,
	`SelectMode`:       16,
	`selectmode`:       16,
	`InactMultiSel`:    17,
	`inactmultisel`:    17,
	`InFocusGrab`:      18,
	`infocusgrab`:      18,
	`InFullRebuild`:    19,
	`infullrebuild`:    19,
}

var _SliceViewFlagsDescMap = map[SliceViewFlags]string{
	9:  `if true, user cannot add elements to the slice`,
	10: `if true, user cannot delete elements from the slice`,
	11: `if the type we&#39;re viewing has its own CtxtMenu property defined, should we also still show the view&#39;s standard context menu?`,
	12: `whether the slice is actually an array -- no modifications -- set by SetSlice`,
	13: `whether to show index or not`,
	14: `whether to show the toolbar or not`,
	15: `support key navigation when inactive (default true) -- no focus really plausible in inactive case, so it uses a low-pri capture of up / down events`,
	16: `editing-mode select rows mode`,
	17: `if view is inactive, default selection mode is to choose one row only -- if this is true, standard multiple selection logic with modifier keys is instead supported`,
	18: `guard for recursive focus grabbing`,
	19: `guard for recursive rebuild`,
}

var _SliceViewFlagsMap = map[SliceViewFlags]string{
	9:  `NoAdd`,
	10: `NoDelete`,
	11: `ShowViewCtxtMenu`,
	12: `IsArray`,
	13: `ShowIndex`,
	14: `ShowToolbar`,
	15: `InactKeyNav`,
	16: `SelectMode`,
	17: `InactMultiSel`,
	18: `InFocusGrab`,
	19: `InFullRebuild`,
}

// String returns the string representation
// of this SliceViewFlags value.
func (i SliceViewFlags) String() string {
	str := ""
	for _, ie := range _SliceViewFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this SliceViewFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i SliceViewFlags) BitIndexString() string {
	if str, ok := _SliceViewFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the SliceViewFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *SliceViewFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the SliceViewFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *SliceViewFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _SliceViewFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _SliceViewFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type SliceViewFlags")
		}
	}
	return nil
}

// Int64 returns the SliceViewFlags value as an int64.
func (i SliceViewFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the SliceViewFlags value from an int64.
func (i *SliceViewFlags) SetInt64(in int64) {
	*i = SliceViewFlags(in)
}

// Desc returns the description of the SliceViewFlags value.
func (i SliceViewFlags) Desc() string {
	if str, ok := _SliceViewFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SliceViewFlagsValues returns all possible values
// for the type SliceViewFlags.
func SliceViewFlagsValues() []SliceViewFlags {
	return _SliceViewFlagsValues
}

// Values returns all possible values
// for the type SliceViewFlags.
func (i SliceViewFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SliceViewFlagsValues))
	for i, d := range _SliceViewFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type SliceViewFlags.
func (i SliceViewFlags) IsValid() bool {
	_, ok := _SliceViewFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i SliceViewFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *SliceViewFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SliceViewFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SliceViewFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TreeViewFlagsValues = []TreeViewFlags{9, 10}

// TreeViewFlagsN is the highest valid value
// for type TreeViewFlags, plus one.
const TreeViewFlagsN TreeViewFlags = 11

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TreeViewFlagsNoOp() {
	var x [1]struct{}
	_ = x[TreeViewFlagClosed-(9)]
	_ = x[TreeViewFlagSelectMode-(10)]
}

var _TreeViewFlagsNameToValueMap = map[string]TreeViewFlags{
	`Closed`:     9,
	`closed`:     9,
	`SelectMode`: 10,
	`selectmode`: 10,
}

var _TreeViewFlagsDescMap = map[TreeViewFlags]string{
	9:  `TreeViewFlagClosed means node is toggled closed (children not visible) Otherwise Open.`,
	10: `This flag on the Root node determines whether keyboard movements update selection or not.`,
}

var _TreeViewFlagsMap = map[TreeViewFlags]string{
	9:  `Closed`,
	10: `SelectMode`,
}

// String returns the string representation
// of this TreeViewFlags value.
func (i TreeViewFlags) String() string {
	str := ""
	for _, ie := range _TreeViewFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TreeViewFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TreeViewFlags) BitIndexString() string {
	if str, ok := _TreeViewFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TreeViewFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TreeViewFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TreeViewFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TreeViewFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TreeViewFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TreeViewFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type TreeViewFlags")
		}
	}
	return nil
}

// Int64 returns the TreeViewFlags value as an int64.
func (i TreeViewFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TreeViewFlags value from an int64.
func (i *TreeViewFlags) SetInt64(in int64) {
	*i = TreeViewFlags(in)
}

// Desc returns the description of the TreeViewFlags value.
func (i TreeViewFlags) Desc() string {
	if str, ok := _TreeViewFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TreeViewFlagsValues returns all possible values
// for the type TreeViewFlags.
func TreeViewFlagsValues() []TreeViewFlags {
	return _TreeViewFlagsValues
}

// Values returns all possible values
// for the type TreeViewFlags.
func (i TreeViewFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TreeViewFlagsValues))
	for i, d := range _TreeViewFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TreeViewFlags.
func (i TreeViewFlags) IsValid() bool {
	_, ok := _TreeViewFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TreeViewFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TreeViewFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TreeViewFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TreeViewFlags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
