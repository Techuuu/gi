// Code generated by "goki generate"; DO NOT EDIT.

package giv

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

// ArgViewType is the [gti.Type] for [ArgView]
var ArgViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ArgView",
	ShortName:  "giv.ArgView",
	IDName:     "arg-view",
	Doc:        "ArgView represents a slice of reflect.Value's and associated names, for the\npurpose of supplying arguments to methods called via the MethView\nframework.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Args", &gti.Field{Name: "Args", Type: "[]ArgData", Doc: "the args that we are a view onto", Directives: gti.Directives{}}},
		{"Title", &gti.Field{Name: "Title", Type: "string", Doc: "title / prompt to show above the editor fields", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ArgView{},
})

// NewArgView adds a new [ArgView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewArgView(par ki.Ki, name ...string) *ArgView {
	return par.NewChild(ArgViewType, name...).(*ArgView)
}

// KiType returns the [*gti.Type] of [ArgView]
func (t *ArgView) KiType() *gti.Type {
	return ArgViewType
}

// New returns a new [*ArgView] value
func (t *ArgView) New() ki.Ki {
	return &ArgView{}
}

// StructValueViewType is the [gti.Type] for [StructValueView]
var StructValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.StructValueView",
	ShortName:  "giv.StructValueView",
	IDName:     "struct-value-view",
	Doc:        "StructValueView presents a button to edit the struct",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StructValueView{},
})

// NewStructValueView adds a new [StructValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStructValueView(par ki.Ki, name ...string) *StructValueView {
	return par.NewChild(StructValueViewType, name...).(*StructValueView)
}

// KiType returns the [*gti.Type] of [StructValueView]
func (t *StructValueView) KiType() *gti.Type {
	return StructValueViewType
}

// New returns a new [*StructValueView] value
func (t *StructValueView) New() ki.Ki {
	return &StructValueView{}
}

// StructInlineValueViewType is the [gti.Type] for [StructInlineValueView]
var StructInlineValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.StructInlineValueView",
	ShortName:  "giv.StructInlineValueView",
	IDName:     "struct-inline-value-view",
	Doc:        "StructInlineValueView presents a StructViewInline for a struct",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StructInlineValueView{},
})

// NewStructInlineValueView adds a new [StructInlineValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStructInlineValueView(par ki.Ki, name ...string) *StructInlineValueView {
	return par.NewChild(StructInlineValueViewType, name...).(*StructInlineValueView)
}

// KiType returns the [*gti.Type] of [StructInlineValueView]
func (t *StructInlineValueView) KiType() *gti.Type {
	return StructInlineValueViewType
}

// New returns a new [*StructInlineValueView] value
func (t *StructInlineValueView) New() ki.Ki {
	return &StructInlineValueView{}
}

// SliceValueViewType is the [gti.Type] for [SliceValueView]
var SliceValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceValueView",
	ShortName:  "giv.SliceValueView",
	IDName:     "slice-value-view",
	Doc:        "SliceValueView presents a button to edit slices",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IsArray", &gti.Field{Name: "IsArray", Type: "bool", Doc: "", Directives: gti.Directives{}}},
		{"ElType", &gti.Field{Name: "ElType", Type: "reflect.Type", Doc: "", Directives: gti.Directives{}}},
		{"ElIsStruct", &gti.Field{Name: "ElIsStruct", Type: "bool", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceValueView{},
})

// NewSliceValueView adds a new [SliceValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceValueView(par ki.Ki, name ...string) *SliceValueView {
	return par.NewChild(SliceValueViewType, name...).(*SliceValueView)
}

// KiType returns the [*gti.Type] of [SliceValueView]
func (t *SliceValueView) KiType() *gti.Type {
	return SliceValueViewType
}

// New returns a new [*SliceValueView] value
func (t *SliceValueView) New() ki.Ki {
	return &SliceValueView{}
}

// SliceInlineValueViewType is the [gti.Type] for [SliceInlineValueView]
var SliceInlineValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceInlineValueView",
	ShortName:  "giv.SliceInlineValueView",
	IDName:     "slice-inline-value-view",
	Doc:        "SliceInlineValueView presents a SliceViewInline for a map",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceInlineValueView{},
})

// NewSliceInlineValueView adds a new [SliceInlineValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceInlineValueView(par ki.Ki, name ...string) *SliceInlineValueView {
	return par.NewChild(SliceInlineValueViewType, name...).(*SliceInlineValueView)
}

// KiType returns the [*gti.Type] of [SliceInlineValueView]
func (t *SliceInlineValueView) KiType() *gti.Type {
	return SliceInlineValueViewType
}

// New returns a new [*SliceInlineValueView] value
func (t *SliceInlineValueView) New() ki.Ki {
	return &SliceInlineValueView{}
}

// MapValueViewType is the [gti.Type] for [MapValueView]
var MapValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.MapValueView",
	ShortName:  "giv.MapValueView",
	IDName:     "map-value-view",
	Doc:        "MapValueView presents a button to edit maps",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MapValueView{},
})

// NewMapValueView adds a new [MapValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMapValueView(par ki.Ki, name ...string) *MapValueView {
	return par.NewChild(MapValueViewType, name...).(*MapValueView)
}

// KiType returns the [*gti.Type] of [MapValueView]
func (t *MapValueView) KiType() *gti.Type {
	return MapValueViewType
}

// New returns a new [*MapValueView] value
func (t *MapValueView) New() ki.Ki {
	return &MapValueView{}
}

// MapInlineValueViewType is the [gti.Type] for [MapInlineValueView]
var MapInlineValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.MapInlineValueView",
	ShortName:  "giv.MapInlineValueView",
	IDName:     "map-inline-value-view",
	Doc:        "MapInlineValueView presents a MapViewInline for a map",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MapInlineValueView{},
})

// NewMapInlineValueView adds a new [MapInlineValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMapInlineValueView(par ki.Ki, name ...string) *MapInlineValueView {
	return par.NewChild(MapInlineValueViewType, name...).(*MapInlineValueView)
}

// KiType returns the [*gti.Type] of [MapInlineValueView]
func (t *MapInlineValueView) KiType() *gti.Type {
	return MapInlineValueViewType
}

// New returns a new [*MapInlineValueView] value
func (t *MapInlineValueView) New() ki.Ki {
	return &MapInlineValueView{}
}

// KiPtrValueViewType is the [gti.Type] for [KiPtrValueView]
var KiPtrValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.KiPtrValueView",
	ShortName:  "giv.KiPtrValueView",
	IDName:     "ki-ptr-value-view",
	Doc:        "KiPtrValueView provides a chooser for pointers to Ki objects",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &KiPtrValueView{},
})

// NewKiPtrValueView adds a new [KiPtrValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewKiPtrValueView(par ki.Ki, name ...string) *KiPtrValueView {
	return par.NewChild(KiPtrValueViewType, name...).(*KiPtrValueView)
}

// KiType returns the [*gti.Type] of [KiPtrValueView]
func (t *KiPtrValueView) KiType() *gti.Type {
	return KiPtrValueViewType
}

// New returns a new [*KiPtrValueView] value
func (t *KiPtrValueView) New() ki.Ki {
	return &KiPtrValueView{}
}

// BoolValueViewType is the [gti.Type] for [BoolValueView]
var BoolValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.BoolValueView",
	ShortName:  "giv.BoolValueView",
	IDName:     "bool-value-view",
	Doc:        "BoolValueView presents a checkbox for a boolean",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &BoolValueView{},
})

// NewBoolValueView adds a new [BoolValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewBoolValueView(par ki.Ki, name ...string) *BoolValueView {
	return par.NewChild(BoolValueViewType, name...).(*BoolValueView)
}

// KiType returns the [*gti.Type] of [BoolValueView]
func (t *BoolValueView) KiType() *gti.Type {
	return BoolValueViewType
}

// New returns a new [*BoolValueView] value
func (t *BoolValueView) New() ki.Ki {
	return &BoolValueView{}
}

// IntValueViewType is the [gti.Type] for [IntValueView]
var IntValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.IntValueView",
	ShortName:  "giv.IntValueView",
	IDName:     "int-value-view",
	Doc:        "IntValueView presents a spinbox",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &IntValueView{},
})

// NewIntValueView adds a new [IntValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewIntValueView(par ki.Ki, name ...string) *IntValueView {
	return par.NewChild(IntValueViewType, name...).(*IntValueView)
}

// KiType returns the [*gti.Type] of [IntValueView]
func (t *IntValueView) KiType() *gti.Type {
	return IntValueViewType
}

// New returns a new [*IntValueView] value
func (t *IntValueView) New() ki.Ki {
	return &IntValueView{}
}

// FloatValueViewType is the [gti.Type] for [FloatValueView]
var FloatValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.FloatValueView",
	ShortName:  "giv.FloatValueView",
	IDName:     "float-value-view",
	Doc:        "FloatValueView presents a spinbox",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FloatValueView{},
})

// NewFloatValueView adds a new [FloatValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFloatValueView(par ki.Ki, name ...string) *FloatValueView {
	return par.NewChild(FloatValueViewType, name...).(*FloatValueView)
}

// KiType returns the [*gti.Type] of [FloatValueView]
func (t *FloatValueView) KiType() *gti.Type {
	return FloatValueViewType
}

// New returns a new [*FloatValueView] value
func (t *FloatValueView) New() ki.Ki {
	return &FloatValueView{}
}

// EnumValueViewType is the [gti.Type] for [EnumValueView]
var EnumValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.EnumValueView",
	ShortName:  "giv.EnumValueView",
	IDName:     "enum-value-view",
	Doc:        "EnumValueView presents a combobox for choosing enums",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &EnumValueView{},
})

// NewEnumValueView adds a new [EnumValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewEnumValueView(par ki.Ki, name ...string) *EnumValueView {
	return par.NewChild(EnumValueViewType, name...).(*EnumValueView)
}

// KiType returns the [*gti.Type] of [EnumValueView]
func (t *EnumValueView) KiType() *gti.Type {
	return EnumValueViewType
}

// New returns a new [*EnumValueView] value
func (t *EnumValueView) New() ki.Ki {
	return &EnumValueView{}
}

// BitFlagViewType is the [gti.Type] for [BitFlagView]
var BitFlagViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.BitFlagView",
	ShortName:  "giv.BitFlagView",
	IDName:     "bit-flag-view",
	Doc:        "BitFlagView presents a ButtonBox for bitflags",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"AltType", &gti.Field{Name: "AltType", Type: "reflect.Type", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &BitFlagView{},
})

// NewBitFlagView adds a new [BitFlagView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewBitFlagView(par ki.Ki, name ...string) *BitFlagView {
	return par.NewChild(BitFlagViewType, name...).(*BitFlagView)
}

// KiType returns the [*gti.Type] of [BitFlagView]
func (t *BitFlagView) KiType() *gti.Type {
	return BitFlagViewType
}

// New returns a new [*BitFlagView] value
func (t *BitFlagView) New() ki.Ki {
	return &BitFlagView{}
}

// TypeValueViewType is the [gti.Type] for [TypeValueView]
var TypeValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TypeValueView",
	ShortName:  "giv.TypeValueView",
	IDName:     "type-value-view",
	Doc:        "TypeValueView presents a combobox for choosing types",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TypeValueView{},
})

// NewTypeValueView adds a new [TypeValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTypeValueView(par ki.Ki, name ...string) *TypeValueView {
	return par.NewChild(TypeValueViewType, name...).(*TypeValueView)
}

// KiType returns the [*gti.Type] of [TypeValueView]
func (t *TypeValueView) KiType() *gti.Type {
	return TypeValueViewType
}

// New returns a new [*TypeValueView] value
func (t *TypeValueView) New() ki.Ki {
	return &TypeValueView{}
}

// ByteSliceValueViewType is the [gti.Type] for [ByteSliceValueView]
var ByteSliceValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ByteSliceValueView",
	ShortName:  "giv.ByteSliceValueView",
	IDName:     "byte-slice-value-view",
	Doc:        "ByteSliceValueView presents a textfield of the bytes",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ByteSliceValueView{},
})

// NewByteSliceValueView adds a new [ByteSliceValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewByteSliceValueView(par ki.Ki, name ...string) *ByteSliceValueView {
	return par.NewChild(ByteSliceValueViewType, name...).(*ByteSliceValueView)
}

// KiType returns the [*gti.Type] of [ByteSliceValueView]
func (t *ByteSliceValueView) KiType() *gti.Type {
	return ByteSliceValueViewType
}

// New returns a new [*ByteSliceValueView] value
func (t *ByteSliceValueView) New() ki.Ki {
	return &ByteSliceValueView{}
}

// RuneSliceValueViewType is the [gti.Type] for [RuneSliceValueView]
var RuneSliceValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.RuneSliceValueView",
	ShortName:  "giv.RuneSliceValueView",
	IDName:     "rune-slice-value-view",
	Doc:        "RuneSliceValueView presents a textfield of the bytes",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &RuneSliceValueView{},
})

// NewRuneSliceValueView adds a new [RuneSliceValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewRuneSliceValueView(par ki.Ki, name ...string) *RuneSliceValueView {
	return par.NewChild(RuneSliceValueViewType, name...).(*RuneSliceValueView)
}

// KiType returns the [*gti.Type] of [RuneSliceValueView]
func (t *RuneSliceValueView) KiType() *gti.Type {
	return RuneSliceValueViewType
}

// New returns a new [*RuneSliceValueView] value
func (t *RuneSliceValueView) New() ki.Ki {
	return &RuneSliceValueView{}
}

// NilValueViewType is the [gti.Type] for [NilValueView]
var NilValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.NilValueView",
	ShortName:  "giv.NilValueView",
	IDName:     "nil-value-view",
	Doc:        "NilValueView presents a label saying 'nil' -- for any nil or otherwise unrepresentable items",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &NilValueView{},
})

// NewNilValueView adds a new [NilValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewNilValueView(par ki.Ki, name ...string) *NilValueView {
	return par.NewChild(NilValueViewType, name...).(*NilValueView)
}

// KiType returns the [*gti.Type] of [NilValueView]
func (t *NilValueView) KiType() *gti.Type {
	return NilValueViewType
}

// New returns a new [*NilValueView] value
func (t *NilValueView) New() ki.Ki {
	return &NilValueView{}
}

// TimeValueViewType is the [gti.Type] for [TimeValueView]
var TimeValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TimeValueView",
	ShortName:  "giv.TimeValueView",
	IDName:     "time-value-view",
	Doc:        "TimeValueView presents a text field for a time",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TimeValueView{},
})

// NewTimeValueView adds a new [TimeValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTimeValueView(par ki.Ki, name ...string) *TimeValueView {
	return par.NewChild(TimeValueViewType, name...).(*TimeValueView)
}

// KiType returns the [*gti.Type] of [TimeValueView]
func (t *TimeValueView) KiType() *gti.Type {
	return TimeValueViewType
}

// New returns a new [*TimeValueView] value
func (t *TimeValueView) New() ki.Ki {
	return &TimeValueView{}
}

// ColorMapViewType is the [gti.Type] for [ColorMapView]
var ColorMapViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorMapView",
	ShortName:  "giv.ColorMapView",
	IDName:     "color-map-view",
	Doc:        "ColorMapView is a widget that displays a ColorMap.\nNote that this is not a ValueView widget",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Orient", &gti.Field{Name: "Orient", Type: "mat32.Dims", Doc: "orientation along which to display the spectrum", Directives: gti.Directives{}}},
		{"Map", &gti.Field{Name: "Map", Type: "*colormap.Map", Doc: "the colormap that we view", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorMapView{},
})

// NewColorMapView adds a new [ColorMapView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorMapView(par ki.Ki, name ...string) *ColorMapView {
	return par.NewChild(ColorMapViewType, name...).(*ColorMapView)
}

// KiType returns the [*gti.Type] of [ColorMapView]
func (t *ColorMapView) KiType() *gti.Type {
	return ColorMapViewType
}

// New returns a new [*ColorMapView] value
func (t *ColorMapView) New() ki.Ki {
	return &ColorMapView{}
}

// ColorMapValueViewType is the [gti.Type] for [ColorMapValueView]
var ColorMapValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorMapValueView",
	ShortName:  "giv.ColorMapValueView",
	IDName:     "color-map-value-view",
	Doc:        "ColorMapValueView presents an button for displaying a ColorMapName and selecting\nmeshes from a ChooserDialog",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorMapValueView{},
})

// NewColorMapValueView adds a new [ColorMapValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorMapValueView(par ki.Ki, name ...string) *ColorMapValueView {
	return par.NewChild(ColorMapValueViewType, name...).(*ColorMapValueView)
}

// KiType returns the [*gti.Type] of [ColorMapValueView]
func (t *ColorMapValueView) KiType() *gti.Type {
	return ColorMapValueViewType
}

// New returns a new [*ColorMapValueView] value
func (t *ColorMapValueView) New() ki.Ki {
	return &ColorMapValueView{}
}

// ColorViewType is the [gti.Type] for [ColorView]
var ColorViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorView",
	ShortName:  "giv.ColorView",
	IDName:     "color-view",
	Doc:        "ColorView shows a color, using sliders or numbers to set values.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "color.RGBA", Doc: "the color that we view", Directives: gti.Directives{}}},
		{"NumView", &gti.Field{Name: "NumView", Type: "ValueView", Doc: "inline struct view of the numbers", Directives: gti.Directives{}}},
		{"ColorHSLA", &gti.Field{Name: "ColorHSLA", Type: "hsl.HSL", Doc: "the color that we view, in HSLA form", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorView{},
})

// NewColorView adds a new [ColorView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorView(par ki.Ki, name ...string) *ColorView {
	return par.NewChild(ColorViewType, name...).(*ColorView)
}

// KiType returns the [*gti.Type] of [ColorView]
func (t *ColorView) KiType() *gti.Type {
	return ColorViewType
}

// New returns a new [*ColorView] value
func (t *ColorView) New() ki.Ki {
	return &ColorView{}
}

// ColorValueViewType is the [gti.Type] for [ColorValueView]
var ColorValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorValueView",
	ShortName:  "giv.ColorValueView",
	IDName:     "color-value-view",
	Doc:        "ColorValueView presents a StructViewInline for a struct plus a ColorView button..",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TmpColor", &gti.Field{Name: "TmpColor", Type: "color.RGBA", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorValueView{},
})

// NewColorValueView adds a new [ColorValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorValueView(par ki.Ki, name ...string) *ColorValueView {
	return par.NewChild(ColorValueViewType, name...).(*ColorValueView)
}

// KiType returns the [*gti.Type] of [ColorValueView]
func (t *ColorValueView) KiType() *gti.Type {
	return ColorValueViewType
}

// New returns a new [*ColorValueView] value
func (t *ColorValueView) New() ki.Ki {
	return &ColorValueView{}
}

// ColorNameValueViewType is the [gti.Type] for [ColorNameValueView]
var ColorNameValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ColorNameValueView",
	ShortName:  "giv.ColorNameValueView",
	IDName:     "color-name-value-view",
	Doc:        "ColorNameValueView presents an button for displaying a ColorNameName and selecting\nmeshes from a ChooserDialog",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ColorNameValueView{},
})

// NewColorNameValueView adds a new [ColorNameValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewColorNameValueView(par ki.Ki, name ...string) *ColorNameValueView {
	return par.NewChild(ColorNameValueViewType, name...).(*ColorNameValueView)
}

// KiType returns the [*gti.Type] of [ColorNameValueView]
func (t *ColorNameValueView) KiType() *gti.Type {
	return ColorNameValueViewType
}

// New returns a new [*ColorNameValueView] value
func (t *ColorNameValueView) New() ki.Ki {
	return &ColorNameValueView{}
}

// DiffViewType is the [gti.Type] for [DiffView]
var DiffViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.DiffView",
	ShortName:  "giv.DiffView",
	IDName:     "diff-view",
	Doc:        "DiffView presents two side-by-side TextView windows showing the differences\nbetween two files (represented as lines of strings).",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FileA", &gti.Field{Name: "FileA", Type: "string", Doc: "first file name being compared", Directives: gti.Directives{}}},
		{"FileB", &gti.Field{Name: "FileB", Type: "string", Doc: "second file name being compared", Directives: gti.Directives{}}},
		{"RevA", &gti.Field{Name: "RevA", Type: "string", Doc: "revision for first file, if relevant", Directives: gti.Directives{}}},
		{"RevB", &gti.Field{Name: "RevB", Type: "string", Doc: "revision for second file, if relevant", Directives: gti.Directives{}}},
		{"Diffs", &gti.Field{Name: "Diffs", Type: "textbuf.Diffs", Doc: "the diff records", Directives: gti.Directives{}}},
		{"BufA", &gti.Field{Name: "BufA", Type: "*TextBuf", Doc: "textbuf for A", Directives: gti.Directives{}}},
		{"BufB", &gti.Field{Name: "BufB", Type: "*TextBuf", Doc: "textbuf for B", Directives: gti.Directives{}}},
		{"AlignD", &gti.Field{Name: "AlignD", Type: "textbuf.Diffs", Doc: "aligned diffs records diff for aligned lines", Directives: gti.Directives{}}},
		{"EditA", &gti.Field{Name: "EditA", Type: "textbuf.Diffs", Doc: "edit diffs records aligned diffs with edits applied", Directives: gti.Directives{}}},
		{"EditB", &gti.Field{Name: "EditB", Type: "textbuf.Diffs", Doc: "edit diffs records aligned diffs with edits applied", Directives: gti.Directives{}}},
		{"UndoA", &gti.Field{Name: "UndoA", Type: "textbuf.Diffs", Doc: "undo diffs records aligned diffs with edits applied", Directives: gti.Directives{}}},
		{"UndoB", &gti.Field{Name: "UndoB", Type: "textbuf.Diffs", Doc: "undo diffs records aligned diffs with edits applied", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &DiffView{},
})

// NewDiffView adds a new [DiffView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewDiffView(par ki.Ki, name ...string) *DiffView {
	return par.NewChild(DiffViewType, name...).(*DiffView)
}

// KiType returns the [*gti.Type] of [DiffView]
func (t *DiffView) KiType() *gti.Type {
	return DiffViewType
}

// New returns a new [*DiffView] value
func (t *DiffView) New() ki.Ki {
	return &DiffView{}
}

// DiffTextViewType is the [gti.Type] for [DiffTextView]
var DiffTextViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.DiffTextView",
	ShortName:  "giv.DiffTextView",
	IDName:     "diff-text-view",
	Doc:        "DiffTextView supports double-click based application of edits from one\nbuffer to the other.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TextView", &gti.Field{Name: "TextView", Type: "TextView", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &DiffTextView{},
})

// NewDiffTextView adds a new [DiffTextView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewDiffTextView(par ki.Ki, name ...string) *DiffTextView {
	return par.NewChild(DiffTextViewType, name...).(*DiffTextView)
}

// KiType returns the [*gti.Type] of [DiffTextView]
func (t *DiffTextView) KiType() *gti.Type {
	return DiffTextViewType
}

// New returns a new [*DiffTextView] value
func (t *DiffTextView) New() ki.Ki {
	return &DiffTextView{}
}

// FileTreeType is the [gti.Type] for [FileTree]
var FileTreeType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.FileTree",
	ShortName:  "giv.FileTree",
	IDName:     "file-tree",
	Doc:        "FileTree is the root of a tree representing files in a given directory (and\nsubdirectories thereof), and has some overall management state for how to\nview things.  The FileTree can be viewed by a TreeView to provide a GUI\ninterface into it.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ExtFiles", &gti.Field{Name: "ExtFiles", Type: "[]string", Doc: "external files outside the root path of the tree -- abs paths are stored -- these are shown in the first sub-node if present -- use AddExtFile to add and update", Directives: gti.Directives{}}},
		{"Dirs", &gti.Field{Name: "Dirs", Type: "DirFlagMap", Doc: "records state of directories within the tree (encoded using paths relative to root), e.g., open (have been opened by the user) -- can persist this to restore prior view of a tree", Directives: gti.Directives{}}},
		{"DirsOnTop", &gti.Field{Name: "DirsOnTop", Type: "bool", Doc: "if true, then all directories are placed at the top of the tree view -- otherwise everything is mixed", Directives: gti.Directives{}}},
		{"NodeType", &gti.Field{Name: "NodeType", Type: "*gti.Type", Doc: "[view: -] type of node to create -- defaults to giv.FileNode but can use custom node types", Directives: gti.Directives{}}},
		{"InOpenAll", &gti.Field{Name: "InOpenAll", Type: "bool", Doc: "if true, we are in midst of an OpenAll call -- nodes should open all dirs", Directives: gti.Directives{}}},
		{"Watcher", &gti.Field{Name: "Watcher", Type: "*fsnotify.Watcher", Doc: "[view: -] change notify for all dirs", Directives: gti.Directives{}}},
		{"DoneWatcher", &gti.Field{Name: "DoneWatcher", Type: "chan bool", Doc: "[view: -] channel to close watcher watcher", Directives: gti.Directives{}}},
		{"WatchedPaths", &gti.Field{Name: "WatchedPaths", Type: "map[string]bool", Doc: "[view: -] map of paths that have been added to watcher -- only active if bool = true", Directives: gti.Directives{}}},
		{"LastWatchUpdt", &gti.Field{Name: "LastWatchUpdt", Type: "string", Doc: "[view: -] last path updated by watcher", Directives: gti.Directives{}}},
		{"LastWatchTime", &gti.Field{Name: "LastWatchTime", Type: "time.Time", Doc: "[view: -] timestamp of last update", Directives: gti.Directives{}}},
		{"UpdtMu", &gti.Field{Name: "UpdtMu", Type: "sync.Mutex", Doc: "[view: -] Update mutex", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FileNode", &gti.Field{Name: "FileNode", Type: "FileNode", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FileTree{},
})

// NewFileTree adds a new [FileTree] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFileTree(par ki.Ki, name ...string) *FileTree {
	return par.NewChild(FileTreeType, name...).(*FileTree)
}

// KiType returns the [*gti.Type] of [FileTree]
func (t *FileTree) KiType() *gti.Type {
	return FileTreeType
}

// New returns a new [*FileTree] value
func (t *FileTree) New() ki.Ki {
	return &FileTree{}
}

// FileNodeType is the [gti.Type] for [FileNode]
var FileNodeType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/giv.FileNode",
	ShortName: "giv.FileNode",
	IDName:    "file-node",
	Doc:       "FileNode represents a file in the file system -- the name of the node is\nthe name of the file.  Folders have children containing further nodes.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FPath", &gti.Field{Name: "FPath", Type: "gi.FileName", Doc: "full path to this file", Directives: gti.Directives{}}},
		{"Info", &gti.Field{Name: "Info", Type: "FileInfo", Doc: "full standard file info about this file", Directives: gti.Directives{}}},
		{"Buf", &gti.Field{Name: "Buf", Type: "*TextBuf", Doc: "file buffer for editing this file", Directives: gti.Directives{}}},
		{"FRoot", &gti.Field{Name: "FRoot", Type: "*FileTree", Doc: "root of the tree -- has global state", Directives: gti.Directives{}}},
		{"DirRepo", &gti.Field{Name: "DirRepo", Type: "vci.Repo", Doc: "version control system repository for this directory, only non-nil if this is the highest-level directory in the tree under vcs control", Directives: gti.Directives{}}},
		{"RepoFiles", &gti.Field{Name: "RepoFiles", Type: "vci.Files", Doc: "version control system repository file status -- only valid during ReadDir", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FileNode{},
})

// NewFileNode adds a new [FileNode] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFileNode(par ki.Ki, name ...string) *FileNode {
	return par.NewChild(FileNodeType, name...).(*FileNode)
}

// KiType returns the [*gti.Type] of [FileNode]
func (t *FileNode) KiType() *gti.Type {
	return FileNodeType
}

// New returns a new [*FileNode] value
func (t *FileNode) New() ki.Ki {
	return &FileNode{}
}

// FileNodeEmbedder is an interface that all types that embed FileNode satisfy
type FileNodeEmbedder interface {
	AsFileNode() *FileNode
}

// AsFileNode returns the given value as a value of type FileNode if the type
// of the given value embeds FileNode, or nil otherwise
func AsFileNode(k ki.Ki) *FileNode {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(FileNodeEmbedder); ok {
		return t.AsFileNode()
	}
	return nil
}

// AsFileNode satisfies the [FileNodeEmbedder] interface
func (t *FileNode) AsFileNode() *FileNode {
	return t
}

// FileTreeViewType is the [gti.Type] for [FileTreeView]
var FileTreeViewType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi/v2/giv.FileTreeView",
	ShortName: "giv.FileTreeView",
	IDName:    "file-tree-view",
	Doc:       "FileTreeView is a TreeView that knows how to operate on FileNode nodes",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "embedder", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TreeView", &gti.Field{Name: "TreeView", Type: "TreeView", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FileTreeView{},
})

// NewFileTreeView adds a new [FileTreeView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFileTreeView(par ki.Ki, name ...string) *FileTreeView {
	return par.NewChild(FileTreeViewType, name...).(*FileTreeView)
}

// KiType returns the [*gti.Type] of [FileTreeView]
func (t *FileTreeView) KiType() *gti.Type {
	return FileTreeViewType
}

// New returns a new [*FileTreeView] value
func (t *FileTreeView) New() ki.Ki {
	return &FileTreeView{}
}

// FileTreeViewEmbedder is an interface that all types that embed FileTreeView satisfy
type FileTreeViewEmbedder interface {
	AsFileTreeView() *FileTreeView
}

// AsFileTreeView returns the given value as a value of type FileTreeView if the type
// of the given value embeds FileTreeView, or nil otherwise
func AsFileTreeView(k ki.Ki) *FileTreeView {
	if k == nil || k.This() == nil {
		return nil
	}
	if t, ok := k.(FileTreeViewEmbedder); ok {
		return t.AsFileTreeView()
	}
	return nil
}

// AsFileTreeView satisfies the [FileTreeViewEmbedder] interface
func (t *FileTreeView) AsFileTreeView() *FileTreeView {
	return t
}

// FileValueViewType is the [gti.Type] for [FileValueView]
var FileValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.FileValueView",
	ShortName:  "giv.FileValueView",
	IDName:     "file-value-view",
	Doc:        "FileValueView presents an action for displaying a FileName and selecting\nicons from FileChooserDialog",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FileValueView{},
})

// NewFileValueView adds a new [FileValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFileValueView(par ki.Ki, name ...string) *FileValueView {
	return par.NewChild(FileValueViewType, name...).(*FileValueView)
}

// KiType returns the [*gti.Type] of [FileValueView]
func (t *FileValueView) KiType() *gti.Type {
	return FileValueViewType
}

// New returns a new [*FileValueView] value
func (t *FileValueView) New() ki.Ki {
	return &FileValueView{}
}

// FileViewType is the [gti.Type] for [FileView]
var FileViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.FileView",
	ShortName:  "giv.FileView",
	IDName:     "file-view",
	Doc:        "FileView is a viewer onto files -- core of the file chooser dialog",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"DirPath", &gti.Field{Name: "DirPath", Type: "string", Doc: "path to directory of files to display", Directives: gti.Directives{}}},
		{"SelFile", &gti.Field{Name: "SelFile", Type: "string", Doc: "selected file", Directives: gti.Directives{}}},
		{"Ext", &gti.Field{Name: "Ext", Type: "string", Doc: "target extension(s) (comma separated if multiple, including initial .), if any", Directives: gti.Directives{}}},
		{"FilterFunc", &gti.Field{Name: "FilterFunc", Type: "FileViewFilterFunc", Doc: "[view: -] optional styling function", Directives: gti.Directives{}}},
		{"ExtMap", &gti.Field{Name: "ExtMap", Type: "map[string]string", Doc: "map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value", Directives: gti.Directives{}}},
		{"Files", &gti.Field{Name: "Files", Type: "[]*FileInfo", Doc: "files for current directory", Directives: gti.Directives{}}},
		{"SelectedIdx", &gti.Field{Name: "SelectedIdx", Type: "int", Doc: "index of currently-selected file in Files list (-1 if none)", Directives: gti.Directives{}}},
		{"Watcher", &gti.Field{Name: "Watcher", Type: "*fsnotify.Watcher", Doc: "[view: -] change notify for current dir", Directives: gti.Directives{}}},
		{"DoneWatcher", &gti.Field{Name: "DoneWatcher", Type: "chan bool", Doc: "[view: -] channel to close watcher watcher", Directives: gti.Directives{}}},
		{"UpdtMu", &gti.Field{Name: "UpdtMu", Type: "sync.Mutex", Doc: "[view: -] UpdateFiles mutex", Directives: gti.Directives{}}},
		{"PrevPath", &gti.Field{Name: "PrevPath", Type: "string", Doc: "[view: -] Previous path that was processed via UpdateFiles", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FileView{},
})

// NewFileView adds a new [FileView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFileView(par ki.Ki, name ...string) *FileView {
	return par.NewChild(FileViewType, name...).(*FileView)
}

// KiType returns the [*gti.Type] of [FileView]
func (t *FileView) KiType() *gti.Type {
	return FileViewType
}

// New returns a new [*FileView] value
func (t *FileView) New() ki.Ki {
	return &FileView{}
}

// FontValueViewType is the [gti.Type] for [FontValueView]
var FontValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.FontValueView",
	ShortName:  "giv.FontValueView",
	IDName:     "font-value-view",
	Doc:        "FontValueView presents an action for displaying a FontName and selecting\nfonts from FontChooserDialog",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &FontValueView{},
})

// NewFontValueView adds a new [FontValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewFontValueView(par ki.Ki, name ...string) *FontValueView {
	return par.NewChild(FontValueViewType, name...).(*FontValueView)
}

// KiType returns the [*gti.Type] of [FontValueView]
func (t *FontValueView) KiType() *gti.Type {
	return FontValueViewType
}

// New returns a new [*FontValueView] value
func (t *FontValueView) New() ki.Ki {
	return &FontValueView{}
}

// GiEditorType is the [gti.Type] for [GiEditor]
var GiEditorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.GiEditor",
	ShortName:  "giv.GiEditor",
	IDName:     "gi-editor",
	Doc:        "GiEditor represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame with an optional title, and a button\nbox at the bottom where methods can be invoked",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"KiRoot", &gti.Field{Name: "KiRoot", Type: "ki.Ki", Doc: "root of tree being edited", Directives: gti.Directives{}}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", Doc: "has the root changed via gui actions?  updated from treeview and structview for changes", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "gi.FileName", Doc: "current filename for saving / loading", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &GiEditor{},
})

// NewGiEditor adds a new [GiEditor] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewGiEditor(par ki.Ki, name ...string) *GiEditor {
	return par.NewChild(GiEditorType, name...).(*GiEditor)
}

// KiType returns the [*gti.Type] of [GiEditor]
func (t *GiEditor) KiType() *gti.Type {
	return GiEditorType
}

// New returns a new [*GiEditor] value
func (t *GiEditor) New() ki.Ki {
	return &GiEditor{}
}

// HiStyleValueViewType is the [gti.Type] for [HiStyleValueView]
var HiStyleValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.HiStyleValueView",
	ShortName:  "giv.HiStyleValueView",
	IDName:     "hi-style-value-view",
	Doc:        "HiStyleValueView presents an action for displaying a mat32.Y and selecting\nfrom styles",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &HiStyleValueView{},
})

// NewHiStyleValueView adds a new [HiStyleValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewHiStyleValueView(par ki.Ki, name ...string) *HiStyleValueView {
	return par.NewChild(HiStyleValueViewType, name...).(*HiStyleValueView)
}

// KiType returns the [*gti.Type] of [HiStyleValueView]
func (t *HiStyleValueView) KiType() *gti.Type {
	return HiStyleValueViewType
}

// New returns a new [*HiStyleValueView] value
func (t *HiStyleValueView) New() ki.Ki {
	return &HiStyleValueView{}
}

// IconValueViewType is the [gti.Type] for [IconValueView]
var IconValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.IconValueView",
	ShortName:  "giv.IconValueView",
	IDName:     "icon-value-view",
	Doc:        "IconValueView presents an action for displaying an IconName and selecting\nicons from IconChooserDialog",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &IconValueView{},
})

// NewIconValueView adds a new [IconValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewIconValueView(par ki.Ki, name ...string) *IconValueView {
	return par.NewChild(IconValueViewType, name...).(*IconValueView)
}

// KiType returns the [*gti.Type] of [IconValueView]
func (t *IconValueView) KiType() *gti.Type {
	return IconValueViewType
}

// New returns a new [*IconValueView] value
func (t *IconValueView) New() ki.Ki {
	return &IconValueView{}
}

// KeyChordValueViewType is the [gti.Type] for [KeyChordValueView]
var KeyChordValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.KeyChordValueView",
	ShortName:  "giv.KeyChordValueView",
	IDName:     "key-chord-value-view",
	Doc:        "KeyChordValueView presents an KeyChordEdit for key.Chord",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &KeyChordValueView{},
})

// NewKeyChordValueView adds a new [KeyChordValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewKeyChordValueView(par ki.Ki, name ...string) *KeyChordValueView {
	return par.NewChild(KeyChordValueViewType, name...).(*KeyChordValueView)
}

// KiType returns the [*gti.Type] of [KeyChordValueView]
func (t *KeyChordValueView) KiType() *gti.Type {
	return KeyChordValueViewType
}

// New returns a new [*KeyChordValueView] value
func (t *KeyChordValueView) New() ki.Ki {
	return &KeyChordValueView{}
}

// KeyChordEditType is the [gti.Type] for [KeyChordEdit]
var KeyChordEditType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.KeyChordEdit",
	ShortName:  "giv.KeyChordEdit",
	IDName:     "key-chord-edit",
	Doc:        "KeyChordEdit is a label widget that shows a key chord string, and, when in\nfocus (after being clicked) will update to whatever key chord is typed --\nused for representing and editing key chords.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FocusActive", &gti.Field{Name: "FocusActive", Type: "bool", Doc: "true if the keyboard focus is active or not -- when we lose active focus we apply changes", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Label", &gti.Field{Name: "gi.Label", Type: "gi.Label", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &KeyChordEdit{},
})

// NewKeyChordEdit adds a new [KeyChordEdit] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewKeyChordEdit(par ki.Ki, name ...string) *KeyChordEdit {
	return par.NewChild(KeyChordEditType, name...).(*KeyChordEdit)
}

// KiType returns the [*gti.Type] of [KeyChordEdit]
func (t *KeyChordEdit) KiType() *gti.Type {
	return KeyChordEditType
}

// New returns a new [*KeyChordEdit] value
func (t *KeyChordEdit) New() ki.Ki {
	return &KeyChordEdit{}
}

// KeyMapValueViewType is the [gti.Type] for [KeyMapValueView]
var KeyMapValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.KeyMapValueView",
	ShortName:  "giv.KeyMapValueView",
	IDName:     "key-map-value-view",
	Doc:        "KeyMapValueView presents an action for displaying a KeyMapName and selecting\nfrom chooser",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &KeyMapValueView{},
})

// NewKeyMapValueView adds a new [KeyMapValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewKeyMapValueView(par ki.Ki, name ...string) *KeyMapValueView {
	return par.NewChild(KeyMapValueViewType, name...).(*KeyMapValueView)
}

// KiType returns the [*gti.Type] of [KeyMapValueView]
func (t *KeyMapValueView) KiType() *gti.Type {
	return KeyMapValueViewType
}

// New returns a new [*KeyMapValueView] value
func (t *KeyMapValueView) New() ki.Ki {
	return &KeyMapValueView{}
}

// MapViewType is the [gti.Type] for [MapView]
var MapViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.MapView",
	ShortName:  "giv.MapView",
	IDName:     "map-view",
	Doc:        "MapView represents a map, creating a property editor of the values --\nconstructs Children widgets to show the key / value pairs, within an\noverall frame.\nAutomatically has a toolbar with Map ToolBar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Map", &gti.Field{Name: "Map", Type: "any", Doc: "the map that we are a view onto", Directives: gti.Directives{}}},
		{"MapValView", &gti.Field{Name: "MapValView", Type: "ValueView", Doc: "ValueView for the map itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", Doc: "has the map been edited?", Directives: gti.Directives{}}},
		{"Keys", &gti.Field{Name: "Keys", Type: "[]ValueView", Doc: "ValueView representations of the map keys", Directives: gti.Directives{}}},
		{"Values", &gti.Field{Name: "Values", Type: "[]ValueView", Doc: "ValueView representations of the map values", Directives: gti.Directives{}}},
		{"SortVals", &gti.Field{Name: "SortVals", Type: "bool", Doc: "sort by values instead of keys", Directives: gti.Directives{}}},
		{"ShowToolBar", &gti.Field{Name: "ShowToolBar", Type: "bool", Doc: "whether to show the toolbar or not", Directives: gti.Directives{}}},
		{"NCols", &gti.Field{Name: "NCols", Type: "int", Doc: "the number of columns in the map; do not set externally; generally only access internally", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
		{"ToolbarMap", &gti.Field{Name: "ToolbarMap", Type: "any", Doc: "the map that we successfully set a toolbar for", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MapView{},
})

// NewMapView adds a new [MapView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMapView(par ki.Ki, name ...string) *MapView {
	return par.NewChild(MapViewType, name...).(*MapView)
}

// KiType returns the [*gti.Type] of [MapView]
func (t *MapView) KiType() *gti.Type {
	return MapViewType
}

// New returns a new [*MapView] value
func (t *MapView) New() ki.Ki {
	return &MapView{}
}

// MapViewInlineType is the [gti.Type] for [MapViewInline]
var MapViewInlineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.MapViewInline",
	ShortName:  "giv.MapViewInline",
	IDName:     "map-view-inline",
	Doc:        "MapViewInline represents a map as a single line widget, for smaller maps\nand those explicitly marked inline -- constructs widgets in Parts to show\nthe key names and editor vals for each value.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Map", &gti.Field{Name: "Map", Type: "any", Doc: "the map that we are a view onto", Directives: gti.Directives{}}},
		{"MapValView", &gti.Field{Name: "MapValView", Type: "ValueView", Doc: "ValueView for the map itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", Doc: "has the map been edited?", Directives: gti.Directives{}}},
		{"Keys", &gti.Field{Name: "Keys", Type: "[]ValueView", Doc: "ValueView representations of the map keys", Directives: gti.Directives{}}},
		{"Values", &gti.Field{Name: "Values", Type: "[]ValueView", Doc: "ValueView representations of the fields", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MapViewInline{},
})

// NewMapViewInline adds a new [MapViewInline] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewMapViewInline(par ki.Ki, name ...string) *MapViewInline {
	return par.NewChild(MapViewInlineType, name...).(*MapViewInline)
}

// KiType returns the [*gti.Type] of [MapViewInline]
func (t *MapViewInline) KiType() *gti.Type {
	return MapViewInlineType
}

// New returns a new [*MapViewInline] value
func (t *MapViewInline) New() ki.Ki {
	return &MapViewInline{}
}

// SliceViewType is the [gti.Type] for [SliceView]
var SliceViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceView",
	ShortName:  "giv.SliceView",
	IDName:     "slice-view",
	Doc:        "SliceView represents a slice, creating an interactive viewer / editor of the\nelements as rows in a table.  Widgets to show the index / value pairs, within an\noverall frame.\nSet to Inactive for select-only mode, which emits WidgetSig WidgetSelected\nsignals when selection is updated.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"StyleFunc", &gti.Field{Name: "StyleFunc", Type: "SliceViewStyleFunc", Doc: "[view: -] optional styling function", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliceViewBase", &gti.Field{Name: "SliceViewBase", Type: "SliceViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceView{},
})

// NewSliceView adds a new [SliceView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceView(par ki.Ki, name ...string) *SliceView {
	return par.NewChild(SliceViewType, name...).(*SliceView)
}

// KiType returns the [*gti.Type] of [SliceView]
func (t *SliceView) KiType() *gti.Type {
	return SliceViewType
}

// New returns a new [*SliceView] value
func (t *SliceView) New() ki.Ki {
	return &SliceView{}
}

// SliceViewBaseType is the [gti.Type] for [SliceViewBase]
var SliceViewBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceViewBase",
	ShortName:  "giv.SliceViewBase",
	IDName:     "slice-view-base",
	Doc:        "SliceViewBase is the base for SliceView and TableView and any other viewers\nof array-like data.  It automatically computes the number of rows that fit\nwithin its allocated space, and manages the offset view window into the full\nlist of items, and supports row selection, copy / paste, Drag-n-Drop, etc.\nSet to Inactive for select-only mode, which emits WidgetSig WidgetSelected\nsignals when selection is updated.\nAutomatically has a toolbar with Slice ToolBar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Slice", &gti.Field{Name: "Slice", Type: "any", Doc: "[view: -] the slice that we are a view onto -- must be a pointer to that slice", Directives: gti.Directives{}}},
		{"ViewMu", &gti.Field{Name: "ViewMu", Type: "*sync.Mutex", Doc: "[view: -] optional mutex that, if non-nil, will be used around any updates that read / modify the underlying Slice data -- can be used to protect against random updating if your code has specific update points that can be likewise protected with this same mutex", Directives: gti.Directives{}}},
		{"SliceNPVal", &gti.Field{Name: "SliceNPVal", Type: "reflect.Value", Doc: "[view: -] non-ptr reflect.Value of the slice", Directives: gti.Directives{}}},
		{"SliceValView", &gti.Field{Name: "SliceValView", Type: "ValueView", Doc: "[view: -] ValueView for the slice itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}}},
		{"isArray", &gti.Field{Name: "isArray", Type: "bool", Doc: "[view: -] whether the slice is actually an array -- no modifications -- set by SetSlice", Directives: gti.Directives{}}},
		{"NoAdd", &gti.Field{Name: "NoAdd", Type: "bool", Doc: "if true, user cannot add elements to the slice", Directives: gti.Directives{}}},
		{"NoDelete", &gti.Field{Name: "NoDelete", Type: "bool", Doc: "if true, user cannot delete elements from the slice", Directives: gti.Directives{}}},
		{"ShowViewCtxtMenu", &gti.Field{Name: "ShowViewCtxtMenu", Type: "bool", Doc: "if the type we're viewing has its own CtxtMenu property defined, should we also still show the view's standard context menu?", Directives: gti.Directives{}}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", Doc: "has the slice been edited?", Directives: gti.Directives{}}},
		{"Values", &gti.Field{Name: "Values", Type: "[]ValueView", Doc: "[view: -] ValueView representations of the slice values", Directives: gti.Directives{}}},
		{"ShowIndex", &gti.Field{Name: "ShowIndex", Type: "bool", Doc: "whether to show index or not", Directives: gti.Directives{}}},
		{"ShowToolBar", &gti.Field{Name: "ShowToolBar", Type: "bool", Doc: "whether to show the toolbar or not", Directives: gti.Directives{}}},
		{"InactKeyNav", &gti.Field{Name: "InactKeyNav", Type: "bool", Doc: "support key navigation when inactive (default true) -- no focus really plausible in inactive case, so it uses a low-pri capture of up / down events", Directives: gti.Directives{}}},
		{"SelVal", &gti.Field{Name: "SelVal", Type: "any", Doc: "[view: -] current selection value -- initially select this value if set", Directives: gti.Directives{}}},
		{"SelectedIdx", &gti.Field{Name: "SelectedIdx", Type: "int", Doc: "index of currently-selected item, in Inactive mode only", Directives: gti.Directives{}}},
		{"SelectMode", &gti.Field{Name: "SelectMode", Type: "bool", Doc: "editing-mode select rows mode", Directives: gti.Directives{}}},
		{"InactMultiSel", &gti.Field{Name: "InactMultiSel", Type: "bool", Doc: "if view is inactive, default selection mode is to choose one row only -- if this is true, standard multiple selection logic with modifier keys is instead supported", Directives: gti.Directives{}}},
		{"SelectedIdxs", &gti.Field{Name: "SelectedIdxs", Type: "map[int]struct{}", Doc: "list of currently-selected slice indexes", Directives: gti.Directives{}}},
		{"DraggedIdxs", &gti.Field{Name: "DraggedIdxs", Type: "[]int", Doc: "list of currently-dragged indexes", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ToolbarSlice", &gti.Field{Name: "ToolbarSlice", Type: "any", Doc: "[view: -] the slice that we successfully set a toolbar for", Directives: gti.Directives{}}},
		{"SliceSize", &gti.Field{Name: "SliceSize", Type: "int", Doc: "size of slice", Directives: gti.Directives{}}},
		{"DispRows", &gti.Field{Name: "DispRows", Type: "int", Doc: "actual number of rows displayed = min(VisRows, SliceSize)", Directives: gti.Directives{}}},
		{"StartIdx", &gti.Field{Name: "StartIdx", Type: "int", Doc: "starting slice index of visible rows", Directives: gti.Directives{}}},
		{"RowHeight", &gti.Field{Name: "RowHeight", Type: "float32", Doc: "height of a single row", Directives: gti.Directives{}}},
		{"VisRows", &gti.Field{Name: "VisRows", Type: "int", Doc: "total number of rows visible in allocated display size", Directives: gti.Directives{}}},
		{"LayoutHeight", &gti.Field{Name: "LayoutHeight", Type: "float32", Doc: "[view: -] the height of grid from last layout -- determines when update needed", Directives: gti.Directives{}}},
		{"RenderedRows", &gti.Field{Name: "RenderedRows", Type: "int", Doc: "[view: -] the number of rows rendered -- determines update", Directives: gti.Directives{}}},
		{"InFocusGrab", &gti.Field{Name: "InFocusGrab", Type: "bool", Doc: "[view: -] guard for recursive focus grabbing", Directives: gti.Directives{}}},
		{"InFullRebuild", &gti.Field{Name: "InFullRebuild", Type: "bool", Doc: "[view: -] guard for recursive rebuild", Directives: gti.Directives{}}},
		{"CurIdx", &gti.Field{Name: "CurIdx", Type: "int", Doc: "[view: -] temp idx state for e.g., dnd", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceViewBase{},
})

// NewSliceViewBase adds a new [SliceViewBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceViewBase(par ki.Ki, name ...string) *SliceViewBase {
	return par.NewChild(SliceViewBaseType, name...).(*SliceViewBase)
}

// KiType returns the [*gti.Type] of [SliceViewBase]
func (t *SliceViewBase) KiType() *gti.Type {
	return SliceViewBaseType
}

// New returns a new [*SliceViewBase] value
func (t *SliceViewBase) New() ki.Ki {
	return &SliceViewBase{}
}

// SliceViewInlineType is the [gti.Type] for [SliceViewInline]
var SliceViewInlineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.SliceViewInline",
	ShortName:  "giv.SliceViewInline",
	IDName:     "slice-view-inline",
	Doc:        "SliceViewInline represents a slice as a single line widget, for smaller\nslices and those explicitly marked inline -- constructs widgets in Parts to\nshow the key names and editor vals for each value.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Slice", &gti.Field{Name: "Slice", Type: "any", Doc: "the slice that we are a view onto", Directives: gti.Directives{}}},
		{"SliceValView", &gti.Field{Name: "SliceValView", Type: "ValueView", Doc: "ValueView for the slice itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}}},
		{"IsArray", &gti.Field{Name: "IsArray", Type: "bool", Doc: "whether the slice is actually an array -- no modifications", Directives: gti.Directives{}}},
		{"IsFixedLen", &gti.Field{Name: "IsFixedLen", Type: "bool", Doc: "whether the slice has a fixed-len flag on it", Directives: gti.Directives{}}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", Doc: "has the slice been edited?", Directives: gti.Directives{}}},
		{"Values", &gti.Field{Name: "Values", Type: "[]ValueView", Doc: "ValueView representations of the fields", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliceViewInline{},
})

// NewSliceViewInline adds a new [SliceViewInline] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSliceViewInline(par ki.Ki, name ...string) *SliceViewInline {
	return par.NewChild(SliceViewInlineType, name...).(*SliceViewInline)
}

// KiType returns the [*gti.Type] of [SliceViewInline]
func (t *SliceViewInline) KiType() *gti.Type {
	return SliceViewInlineType
}

// New returns a new [*SliceViewInline] value
func (t *SliceViewInline) New() ki.Ki {
	return &SliceViewInline{}
}

// StructViewType is the [gti.Type] for [StructView]
var StructViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.StructView",
	ShortName:  "giv.StructView",
	IDName:     "struct-view",
	Doc:        "StructView represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame.\nAutomatically has a toolbar with Struct ToolBar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Struct", &gti.Field{Name: "Struct", Type: "any", Doc: "the struct that we are a view onto", Directives: gti.Directives{}}},
		{"StructValView", &gti.Field{Name: "StructValView", Type: "ValueView", Doc: "ValueView for the struct itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}}},
		{"Changed", &gti.Field{Name: "Changed", Type: "bool", Doc: "has the value of any field changed?  updated by the ViewSig signals from fields", Directives: gti.Directives{}}},
		{"ChangeFlag", &gti.Field{Name: "ChangeFlag", Type: "*reflect.Value", Doc: "ValueView for a field marked with changeflag struct tag, which must be a bool type, which is updated when changes are registered in field values.", Directives: gti.Directives{}}},
		{"FieldViews", &gti.Field{Name: "FieldViews", Type: "[]ValueView", Doc: "ValueView representations of the fields", Directives: gti.Directives{}}},
		{"ShowToolBar", &gti.Field{Name: "ShowToolBar", Type: "bool", Doc: "whether to show the toolbar or not", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
		{"ToolbarStru", &gti.Field{Name: "ToolbarStru", Type: "any", Doc: "the struct that we successfully set a toolbar for", Directives: gti.Directives{}}},
		{"HasDefs", &gti.Field{Name: "HasDefs", Type: "bool", Doc: "if true, some fields have default values -- update labels when values change", Directives: gti.Directives{}}},
		{"HasViewIfs", &gti.Field{Name: "HasViewIfs", Type: "bool", Doc: "if true, some fields have viewif conditional view tags -- update after..", Directives: gti.Directives{}}},
		{"TypeFieldTags", &gti.Field{Name: "TypeFieldTags", Type: "map[string]string", Doc: "extra tags by field name -- from type properties", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Frame", &gti.Field{Name: "gi.Frame", Type: "gi.Frame", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StructView{},
})

// NewStructView adds a new [StructView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStructView(par ki.Ki, name ...string) *StructView {
	return par.NewChild(StructViewType, name...).(*StructView)
}

// KiType returns the [*gti.Type] of [StructView]
func (t *StructView) KiType() *gti.Type {
	return StructViewType
}

// New returns a new [*StructView] value
func (t *StructView) New() ki.Ki {
	return &StructView{}
}

// StructViewInlineType is the [gti.Type] for [StructViewInline]
var StructViewInlineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.StructViewInline",
	ShortName:  "giv.StructViewInline",
	IDName:     "struct-view-inline",
	Doc:        "StructViewInline represents a struct as a single line widget, for smaller\nstructs and those explicitly marked inline in the kit type registry type\nproperties -- constructs widgets in Parts to show the field names and\neditor fields for each field",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Struct", &gti.Field{Name: "Struct", Type: "any", Doc: "the struct that we are a view onto", Directives: gti.Directives{}}},
		{"StructValView", &gti.Field{Name: "StructValView", Type: "ValueView", Doc: "ValueView for the struct itself, if this was created within value view framework -- otherwise nil", Directives: gti.Directives{}}},
		{"AddButton", &gti.Field{Name: "AddButton", Type: "bool", Doc: "if true add an edit action button at the end -- other users of this widget can then configure that -- it is called 'edit-action'", Directives: gti.Directives{}}},
		{"FieldViews", &gti.Field{Name: "FieldViews", Type: "[]ValueView", Doc: "ValueView representations of the fields", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
		{"HasDefs", &gti.Field{Name: "HasDefs", Type: "bool", Doc: "[view: inactive] if true, some fields have default values -- update labels when values change", Directives: gti.Directives{}}},
		{"HasViewIfs", &gti.Field{Name: "HasViewIfs", Type: "bool", Doc: "if true, some fields have viewif conditional view tags -- update after..", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StructViewInline{},
})

// NewStructViewInline adds a new [StructViewInline] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewStructViewInline(par ki.Ki, name ...string) *StructViewInline {
	return par.NewChild(StructViewInlineType, name...).(*StructViewInline)
}

// KiType returns the [*gti.Type] of [StructViewInline]
func (t *StructViewInline) KiType() *gti.Type {
	return StructViewInlineType
}

// New returns a new [*StructViewInline] value
func (t *StructViewInline) New() ki.Ki {
	return &StructViewInline{}
}

// EditorType is the [gti.Type] for [Editor]
var EditorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.Editor",
	ShortName:  "giv.Editor",
	IDName:     "editor",
	Doc:        "Editor supports editing of SVG elements",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Trans", &gti.Field{Name: "Trans", Type: "mat32.Vec2", Doc: "view translation offset (from dragging)", Directives: gti.Directives{}}},
		{"Scale", &gti.Field{Name: "Scale", Type: "float32", Doc: "view scaling (from zooming)", Directives: gti.Directives{}}},
		{"SetDragCursor", &gti.Field{Name: "SetDragCursor", Type: "bool", Doc: "[view: -] has dragging cursor been set yet?", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Editor{},
})

// NewEditor adds a new [Editor] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewEditor(par ki.Ki, name ...string) *Editor {
	return par.NewChild(EditorType, name...).(*Editor)
}

// KiType returns the [*gti.Type] of [Editor]
func (t *Editor) KiType() *gti.Type {
	return EditorType
}

// New returns a new [*Editor] value
func (t *Editor) New() ki.Ki {
	return &Editor{}
}

// TableViewType is the [gti.Type] for [TableView]
var TableViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TableView",
	ShortName:  "giv.TableView",
	IDName:     "table-view",
	Doc:        "TableView represents a slice-of-structs as a table, where the fields are\nthe columns, within an overall frame.  It has two modes, determined by\nInactive flag: if Inactive, it functions as a mutually-exclusive item\nselector, highlighting the selected row and emitting a WidgetSig\nWidgetSelected signal, and TableViewDoubleClick for double clicks (can be\nused for closing dialogs).  If !Inactive, it is a full-featured editor with\nmultiple-selection, cut-and-paste, and drag-and-drop, reporting each action\ntaken using the TableViewSig signals\nAutomatically has a toolbar with Slice ToolBar props if defined\nset prop toolbar = false to turn off",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"StyleFunc", &gti.Field{Name: "StyleFunc", Type: "TableViewStyleFunc", Doc: "[view: -] optional styling function", Directives: gti.Directives{}}},
		{"SelField", &gti.Field{Name: "SelField", Type: "string", Doc: "[view: -] current selection field -- initially select value in this field", Directives: gti.Directives{}}},
		{"SortIdx", &gti.Field{Name: "SortIdx", Type: "int", Doc: "current sort index", Directives: gti.Directives{}}},
		{"SortDesc", &gti.Field{Name: "SortDesc", Type: "bool", Doc: "whether current sort order is descending", Directives: gti.Directives{}}},
		{"StruType", &gti.Field{Name: "StruType", Type: "reflect.Type", Doc: "[view: -] struct type for each row", Directives: gti.Directives{}}},
		{"VisFields", &gti.Field{Name: "VisFields", Type: "[]reflect.StructField", Doc: "[view: -] the visible fields", Directives: gti.Directives{}}},
		{"NVisFields", &gti.Field{Name: "NVisFields", Type: "int", Doc: "[view: -] number of visible fields", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliceViewBase", &gti.Field{Name: "SliceViewBase", Type: "SliceViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TableView{},
})

// NewTableView adds a new [TableView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTableView(par ki.Ki, name ...string) *TableView {
	return par.NewChild(TableViewType, name...).(*TableView)
}

// KiType returns the [*gti.Type] of [TableView]
func (t *TableView) KiType() *gti.Type {
	return TableViewType
}

// New returns a new [*TableView] value
func (t *TableView) New() ki.Ki {
	return &TableView{}
}

// TextBufType is the [gti.Type] for [TextBuf]
var TextBufType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TextBuf",
	ShortName:  "giv.TextBuf",
	IDName:     "text-buf",
	Doc:        "TextBuf is a buffer of text, which can be viewed by TextView(s).  It holds\nthe raw text lines (in original string and rune formats, and marked-up from\nsyntax highlighting), and sends signals for making edits to the text and\ncoordinating those edits across multiple views.  Views always only view a\nsingle buffer, so they directly call methods on the buffer to drive\nupdates, which are then broadcast.  It also has methods for loading and\nsaving buffers to files.  Unlike GUI Widgets, its methods are generally\nsignaling, without an explicit Action suffix.  Internally, the buffer\nrepresents new lines using \\n = LF, but saving and loading can deal with\nRenderWins/DOS CRLF format.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Txt", &gti.Field{Name: "Txt", Type: "[]byte", Doc: "the current value of the entire text being edited -- using []byte slice for greater efficiency", Directives: gti.Directives{}}},
		{"Autosave", &gti.Field{Name: "Autosave", Type: "bool", Doc: "if true, auto-save file after changes (in a separate routine)", Directives: gti.Directives{}}},
		{"Opts", &gti.Field{Name: "Opts", Type: "textbuf.Opts", Doc: "options for how text editing / viewing works", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "gi.FileName", Doc: "filename of file last loaded or saved", Directives: gti.Directives{}}},
		{"Info", &gti.Field{Name: "Info", Type: "FileInfo", Doc: "full info about file", Directives: gti.Directives{}}},
		{"PiState", &gti.Field{Name: "PiState", Type: "pi.FileStates", Doc: "Pi parsing state info for file", Directives: gti.Directives{}}},
		{"Hi", &gti.Field{Name: "Hi", Type: "HiMarkup", Doc: "syntax highlighting markup parameters (language, style, etc)", Directives: gti.Directives{}}},
		{"NLines", &gti.Field{Name: "NLines", Type: "int", Doc: "number of lines", Directives: gti.Directives{}}},
		{"LineIcons", &gti.Field{Name: "LineIcons", Type: "map[int]icons.Icon", Doc: "icons for given lines -- use SetLineIcon and DeleteLineIcon", Directives: gti.Directives{}}},
		{"LineColors", &gti.Field{Name: "LineColors", Type: "map[int]color.RGBA", Doc: "special line number colors given lines -- use SetLineColor and DeleteLineColor", Directives: gti.Directives{}}},
		{"Icons", &gti.Field{Name: "Icons", Type: "map[icons.Icon]*gi.Icon", Doc: "icons for each LineIcons being used", Directives: gti.Directives{}}},
		{"Lines", &gti.Field{Name: "Lines", Type: "[][]rune", Doc: "the live lines of text being edited, with latest modifications -- encoded as runes per line, which is necessary for one-to-one rune / glyph rendering correspondence -- all TextPos positions etc are in *rune* indexes, not byte indexes!", Directives: gti.Directives{}}},
		{"LineBytes", &gti.Field{Name: "LineBytes", Type: "[][]byte", Doc: "the live lines of text being edited, with latest modifications -- encoded in bytes per line translated from Lines, and used for input to markup -- essential to use Lines and not LineBytes when dealing with TextPos positions, which are in runes", Directives: gti.Directives{}}},
		{"Tags", &gti.Field{Name: "Tags", Type: "[]lex.Line", Doc: "", Directives: gti.Directives{}}},
		{"HiTags", &gti.Field{Name: "HiTags", Type: "[]lex.Line", Doc: "", Directives: gti.Directives{}}},
		{"Markup", &gti.Field{Name: "Markup", Type: "[][]byte", Doc: "marked-up version of the edit text lines, after being run through the syntax highlighting process etc -- this is what is actually rendered", Directives: gti.Directives{}}},
		{"MarkupEdits", &gti.Field{Name: "MarkupEdits", Type: "[]*textbuf.Edit", Doc: "edits that have been made since last full markup", Directives: gti.Directives{}}},
		{"ByteOffs", &gti.Field{Name: "ByteOffs", Type: "[]int", Doc: "offsets for start of each line in Txt []byte slice -- this is NOT updated with edits -- call SetByteOffs to set it when needed -- used for re-generating the Txt in LinesToBytes, and set on initial open in BytesToLines", Directives: gti.Directives{}}},
		{"TotalBytes", &gti.Field{Name: "TotalBytes", Type: "int", Doc: "total bytes in document -- see ByteOffs for when it is updated", Directives: gti.Directives{}}},
		{"LinesMu", &gti.Field{Name: "LinesMu", Type: "sync.RWMutex", Doc: "mutex for updating lines", Directives: gti.Directives{}}},
		{"MarkupMu", &gti.Field{Name: "MarkupMu", Type: "sync.RWMutex", Doc: "mutex for updating markup", Directives: gti.Directives{}}},
		{"MarkupDelayTimer", &gti.Field{Name: "MarkupDelayTimer", Type: "*time.Timer", Doc: "markup delay timer", Directives: gti.Directives{}}},
		{"MarkupDelayMu", &gti.Field{Name: "MarkupDelayMu", Type: "sync.Mutex", Doc: "mutex for updating markup delay timer", Directives: gti.Directives{}}},
		{"Views", &gti.Field{Name: "Views", Type: "[]*TextView", Doc: "the TextViews that are currently viewing this buffer", Directives: gti.Directives{}}},
		{"Undos", &gti.Field{Name: "Undos", Type: "textbuf.Undo", Doc: "undo manager", Directives: gti.Directives{}}},
		{"PosHistory", &gti.Field{Name: "PosHistory", Type: "[]lex.Pos", Doc: "history of cursor positions -- can move back through them", Directives: gti.Directives{}}},
		{"CurView", &gti.Field{Name: "CurView", Type: "*TextView", Doc: "current textview -- e.g., the one that initiated Complete or Correct process -- update cursor position in this view -- is reset to nil after usage always", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TextBuf{},
})

// NewTextBuf adds a new [TextBuf] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTextBuf(par ki.Ki, name ...string) *TextBuf {
	return par.NewChild(TextBufType, name...).(*TextBuf)
}

// KiType returns the [*gti.Type] of [TextBuf]
func (t *TextBuf) KiType() *gti.Type {
	return TextBufType
}

// New returns a new [*TextBuf] value
func (t *TextBuf) New() ki.Ki {
	return &TextBuf{}
}

// TextViewType is the [gti.Type] for [TextView]
var TextViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TextView",
	ShortName:  "giv.TextView",
	IDName:     "text-view",
	Doc:        "TextView is a widget for editing multiple lines of text (as compared to\nTextField for a single line).  The View is driven by a TextBuf buffer which\ncontains all the text, and manages all the edits, sending update signals\nout to the views -- multiple views can be attached to a given buffer.  All\nupdating in the TextView should be within a single goroutine -- it would\nrequire extensive protections throughout code otherwise.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Buf", &gti.Field{Name: "Buf", Type: "*TextBuf", Doc: "the text buffer that we're editing", Directives: gti.Directives{}}},
		{"Placeholder", &gti.Field{Name: "Placeholder", Type: "string", Doc: "text that is displayed when the field is empty, in a lower-contrast manner", Directives: gti.Directives{}}},
		{"CursorWidth", &gti.Field{Name: "CursorWidth", Type: "units.Value", Doc: "width of cursor -- set from cursor-width property (inherited)", Directives: gti.Directives{}}},
		{"LineNumberColor", &gti.Field{Name: "LineNumberColor", Type: "colors.Full", Doc: "the color used for the side bar containing the line numbers; this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"SelectColor", &gti.Field{Name: "SelectColor", Type: "colors.Full", Doc: "the color used for the user text selection background color; this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"HighlightColor", &gti.Field{Name: "HighlightColor", Type: "colors.Full", Doc: "the color used for the text highlight background color (like in find); this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"CursorColor", &gti.Field{Name: "CursorColor", Type: "colors.Full", Doc: "the color used for the text field cursor (caret); this should be set in Stylers like all other style properties", Directives: gti.Directives{}}},
		{"NLines", &gti.Field{Name: "NLines", Type: "int", Doc: "number of lines in the view -- sync'd with the Buf after edits, but always reflects storage size of Renders etc", Directives: gti.Directives{}}},
		{"Renders", &gti.Field{Name: "Renders", Type: "[]paint.Text", Doc: "renders of the text lines, with one render per line (each line could visibly wrap-around, so these are logical lines, not display lines)", Directives: gti.Directives{}}},
		{"Offs", &gti.Field{Name: "Offs", Type: "[]float32", Doc: "starting offsets for top of each line", Directives: gti.Directives{}}},
		{"LineNoDigs", &gti.Field{Name: "LineNoDigs", Type: "int", Doc: "number of line number digits needed", Directives: gti.Directives{}}},
		{"LineNoOff", &gti.Field{Name: "LineNoOff", Type: "float32", Doc: "horizontal offset for start of text after line numbers", Directives: gti.Directives{}}},
		{"LineNoRender", &gti.Field{Name: "LineNoRender", Type: "paint.Text", Doc: "render for line numbers", Directives: gti.Directives{}}},
		{"LinesSize", &gti.Field{Name: "LinesSize", Type: "image.Point", Doc: "total size of all lines as rendered", Directives: gti.Directives{}}},
		{"RenderSz", &gti.Field{Name: "RenderSz", Type: "mat32.Vec2", Doc: "size params to use in render call", Directives: gti.Directives{}}},
		{"CursorPos", &gti.Field{Name: "CursorPos", Type: "lex.Pos", Doc: "current cursor position", Directives: gti.Directives{}}},
		{"CursorCol", &gti.Field{Name: "CursorCol", Type: "int", Doc: "desired cursor column -- where the cursor was last when moved using left / right arrows -- used when doing up / down to not always go to short line columns", Directives: gti.Directives{}}},
		{"ScrollToCursorOnRender", &gti.Field{Name: "ScrollToCursorOnRender", Type: "bool", Doc: "if true, scroll screen to cursor on next render", Directives: gti.Directives{}}},
		{"ScrollToCursorPos", &gti.Field{Name: "ScrollToCursorPos", Type: "lex.Pos", Doc: "cursor position to scroll to", Directives: gti.Directives{}}},
		{"PosHistIdx", &gti.Field{Name: "PosHistIdx", Type: "int", Doc: "current index within PosHistory", Directives: gti.Directives{}}},
		{"SelectStart", &gti.Field{Name: "SelectStart", Type: "lex.Pos", Doc: "starting point for selection -- will either be the start or end of selected region depending on subsequent selection.", Directives: gti.Directives{}}},
		{"SelectReg", &gti.Field{Name: "SelectReg", Type: "textbuf.Region", Doc: "current selection region", Directives: gti.Directives{}}},
		{"PrevSelectReg", &gti.Field{Name: "PrevSelectReg", Type: "textbuf.Region", Doc: "previous selection region, that was actually rendered -- needed to update render", Directives: gti.Directives{}}},
		{"Highlights", &gti.Field{Name: "Highlights", Type: "[]textbuf.Region", Doc: "highlighted regions, e.g., for search results", Directives: gti.Directives{}}},
		{"Scopelights", &gti.Field{Name: "Scopelights", Type: "[]textbuf.Region", Doc: "highlighted regions, specific to scope markers", Directives: gti.Directives{}}},
		{"SelectMode", &gti.Field{Name: "SelectMode", Type: "bool", Doc: "if true, select text as cursor moves", Directives: gti.Directives{}}},
		{"ForceComplete", &gti.Field{Name: "ForceComplete", Type: "bool", Doc: "if true, complete regardless of any disqualifying reasons", Directives: gti.Directives{}}},
		{"ISearch", &gti.Field{Name: "ISearch", Type: "ISearch", Doc: "interactive search data", Directives: gti.Directives{}}},
		{"QReplace", &gti.Field{Name: "QReplace", Type: "QReplace", Doc: "query replace data", Directives: gti.Directives{}}},
		{"FontHeight", &gti.Field{Name: "FontHeight", Type: "float32", Doc: "font height, cached during styling", Directives: gti.Directives{}}},
		{"LineHeight", &gti.Field{Name: "LineHeight", Type: "float32", Doc: "line height, cached during styling", Directives: gti.Directives{}}},
		{"VisSize", &gti.Field{Name: "VisSize", Type: "image.Point", Doc: "height in lines and width in chars of the visible area", Directives: gti.Directives{}}},
		{"BlinkOn", &gti.Field{Name: "BlinkOn", Type: "bool", Doc: "oscillates between on and off for blinking", Directives: gti.Directives{}}},
		{"CursorMu", &gti.Field{Name: "CursorMu", Type: "sync.Mutex", Doc: "[view: -] mutex protecting cursor rendering -- shared between blink and main code", Directives: gti.Directives{}}},
		{"HasLinks", &gti.Field{Name: "HasLinks", Type: "bool", Doc: "at least one of the renders has links -- determines if we set the cursor for hand movements", Directives: gti.Directives{}}},
		{"lastRecenter", &gti.Field{Name: "lastRecenter", Type: "int", Doc: "", Directives: gti.Directives{}}},
		{"lastAutoInsert", &gti.Field{Name: "lastAutoInsert", Type: "rune", Doc: "", Directives: gti.Directives{}}},
		{"lastFilename", &gti.Field{Name: "lastFilename", Type: "gi.FileName", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TextView{},
})

// NewTextView adds a new [TextView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTextView(par ki.Ki, name ...string) *TextView {
	return par.NewChild(TextViewType, name...).(*TextView)
}

// KiType returns the [*gti.Type] of [TextView]
func (t *TextView) KiType() *gti.Type {
	return TextViewType
}

// New returns a new [*TextView] value
func (t *TextView) New() ki.Ki {
	return &TextView{}
}

// TreeViewType is the [gti.Type] for [TreeView]
var TreeViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TreeView",
	ShortName:  "giv.TreeView",
	IDName:     "tree-view",
	Doc:        "TreeView provides a graphical representation of source tree structure\n(which can be any type of Ki nodes), providing full manipulation abilities\nof that source tree (move, cut, add, etc) through drag-n-drop and\ncut/copy/paste and menu actions.\n\nThere are special style Props interpreted by these nodes:\n  - no-templates -- if present (assumed to be true) then style templates are\n    not used to optimize rendering speed.  Set this for nodes that have\n    styling applied differentially to individual nodes (e.g., FileNode).",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SrcNode", &gti.Field{Name: "SrcNode", Type: "ki.Ki", Doc: "Ki Node that this widget is viewing in the tree -- the source", Directives: gti.Directives{}}},
		{"ShowViewCtxtMenu", &gti.Field{Name: "ShowViewCtxtMenu", Type: "bool", Doc: "if the object we're viewing has its own CtxtMenu property defined, should we also still show the view's own context menu?", Directives: gti.Directives{}}},
		{"ViewIdx", &gti.Field{Name: "ViewIdx", Type: "int", Doc: "linear index of this node within the entire tree -- updated on full rebuilds and may sometimes be off, but close enough for expected uses", Directives: gti.Directives{}}},
		{"Indent", &gti.Field{Name: "Indent", Type: "units.Value", Doc: "styled amount to indent children relative to this node", Directives: gti.Directives{}}},
		{"OpenDepth", &gti.Field{Name: "OpenDepth", Type: "int", Doc: "styled depth for nodes be initialized as open -- nodes beyond this depth will be initialized as closed.  initial default is 4.", Directives: gti.Directives{}}},
		{"WidgetSize", &gti.Field{Name: "WidgetSize", Type: "mat32.Vec2", Doc: "just the size of our widget -- our alloc includes all of our children, but we only draw us", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "icons.Icon", Doc: "[view: show-name] optional icon, displayed to the the left of the text label", Directives: gti.Directives{}}},
		{"RootView", &gti.Field{Name: "RootView", Type: "*TreeView", Doc: "cached root of the view", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.WidgetBase", &gti.Field{Name: "gi.WidgetBase", Type: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TreeView{},
})

// NewTreeView adds a new [TreeView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTreeView(par ki.Ki, name ...string) *TreeView {
	return par.NewChild(TreeViewType, name...).(*TreeView)
}

// KiType returns the [*gti.Type] of [TreeView]
func (t *TreeView) KiType() *gti.Type {
	return TreeViewType
}

// New returns a new [*TreeView] value
func (t *TreeView) New() ki.Ki {
	return &TreeView{}
}

// TwinTextViewsType is the [gti.Type] for [TwinTextViews]
var TwinTextViewsType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.TwinTextViews",
	ShortName:  "giv.TwinTextViews",
	IDName:     "twin-text-views",
	Doc:        "TwinTextViews presents two side-by-side TextView windows in Splits\nthat scroll in sync with each other.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"BufA", &gti.Field{Name: "BufA", Type: "*TextBuf", Doc: "textbuf for A", Directives: gti.Directives{}}},
		{"BufB", &gti.Field{Name: "BufB", Type: "*TextBuf", Doc: "textbuf for B", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Splits", &gti.Field{Name: "gi.Splits", Type: "gi.Splits", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TwinTextViews{},
})

// NewTwinTextViews adds a new [TwinTextViews] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewTwinTextViews(par ki.Ki, name ...string) *TwinTextViews {
	return par.NewChild(TwinTextViewsType, name...).(*TwinTextViews)
}

// KiType returns the [*gti.Type] of [TwinTextViews]
func (t *TwinTextViews) KiType() *gti.Type {
	return TwinTextViewsType
}

// New returns a new [*TwinTextViews] value
func (t *TwinTextViews) New() ki.Ki {
	return &TwinTextViews{}
}

// ValueViewBaseType is the [gti.Type] for [ValueViewBase]
var ValueViewBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.ValueViewBase",
	ShortName:  "giv.ValueViewBase",
	IDName:     "value-view-base",
	Doc:        "ValueViewBase provides the basis for implementations of the ValueView\ninterface, representing values in the interface -- it implements a generic\nTextField representation of the string value, and provides the generic\nfallback for everything that doesn't provide a specific ValueViewer type.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "reflect.Value", Doc: "the reflect.Value representation of the value", Directives: gti.Directives{}}},
		{"OwnKind", &gti.Field{Name: "OwnKind", Type: "reflect.Kind", Doc: "kind of owner that we have -- reflect.Struct, .Map, .Slice are supported", Directives: gti.Directives{}}},
		{"IsMapKey", &gti.Field{Name: "IsMapKey", Type: "bool", Doc: "for OwnKind = Map, this value represents the Key -- otherwise the Value", Directives: gti.Directives{}}},
		{"ViewPath", &gti.Field{Name: "ViewPath", Type: "string", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows", Directives: gti.Directives{}}},
		{"Owner", &gti.Field{Name: "Owner", Type: "any", Doc: "the object that owns this value, either a struct, slice, or map, if non-nil -- if a Ki Node, then SetField is used to set value, to provide proper updating", Directives: gti.Directives{}}},
		{"Field", &gti.Field{Name: "Field", Type: "*reflect.StructField", Doc: "if Owner is a struct, this is the reflect.StructField associated with the value", Directives: gti.Directives{}}},
		{"Tags", &gti.Field{Name: "Tags", Type: "map[string]string", Doc: "set of tags that can be set to customize interface for different types of values -- only source for non-structfield values", Directives: gti.Directives{}}},
		{"Key", &gti.Field{Name: "Key", Type: "any", Doc: "if Owner is a map, and this is a value, this is the key for this value in the map", Directives: gti.Directives{}}},
		{"KeyView", &gti.Field{Name: "KeyView", Type: "ValueView", Doc: "if Owner is a map, and this is a value, this is the value view representing the key -- its value has the *current* value of the key, which can be edited", Directives: gti.Directives{}}},
		{"Idx", &gti.Field{Name: "Idx", Type: "int", Doc: "if Owner is a slice, this is the index for the value in the slice", Directives: gti.Directives{}}},
		{"WidgetTyp", &gti.Field{Name: "WidgetTyp", Type: "*gti.Type", Doc: "type of widget to create -- cached during WidgetType method -- chosen based on the ValueView type and reflect.Value type -- see ValueViewer interface", Directives: gti.Directives{}}},
		{"Widget", &gti.Field{Name: "Widget", Type: "gi.Widget", Doc: "the widget used to display and edit the value in the interface -- this is created for us externally and we cache it during ConfigWidget", Directives: gti.Directives{}}},
		{"Listeners", &gti.Field{Name: "Listeners", Type: "events.Listeners", Doc: "Listeners are event listener functions for processing events on this widget.\ntype specific Listeners are added in OnInit when the widget is initialized.", Directives: gti.Directives{}}},
		{"TmpSave", &gti.Field{Name: "TmpSave", Type: "ValueView", Doc: "value view that needs to have SaveTmp called on it whenever a change is made to one of the underlying values -- pass this down to any sub-views created from a parent", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ValueViewBase{},
})

// NewValueViewBase adds a new [ValueViewBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewValueViewBase(par ki.Ki, name ...string) *ValueViewBase {
	return par.NewChild(ValueViewBaseType, name...).(*ValueViewBase)
}

// KiType returns the [*gti.Type] of [ValueViewBase]
func (t *ValueViewBase) KiType() *gti.Type {
	return ValueViewBaseType
}

// New returns a new [*ValueViewBase] value
func (t *ValueViewBase) New() ki.Ki {
	return &ValueViewBase{}
}

// VersCtrlValueViewType is the [gti.Type] for [VersCtrlValueView]
var VersCtrlValueViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.VersCtrlValueView",
	ShortName:  "giv.VersCtrlValueView",
	IDName:     "vers-ctrl-value-view",
	Doc:        "VersCtrlValueView presents an action for displaying an VersCtrlName and selecting\nfrom StringPopup",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ValueViewBase", &gti.Field{Name: "ValueViewBase", Type: "ValueViewBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &VersCtrlValueView{},
})

// NewVersCtrlValueView adds a new [VersCtrlValueView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewVersCtrlValueView(par ki.Ki, name ...string) *VersCtrlValueView {
	return par.NewChild(VersCtrlValueViewType, name...).(*VersCtrlValueView)
}

// KiType returns the [*gti.Type] of [VersCtrlValueView]
func (t *VersCtrlValueView) KiType() *gti.Type {
	return VersCtrlValueViewType
}

// New returns a new [*VersCtrlValueView] value
func (t *VersCtrlValueView) New() ki.Ki {
	return &VersCtrlValueView{}
}

// VCSLogViewType is the [gti.Type] for [VCSLogView]
var VCSLogViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/giv.VCSLogView",
	ShortName:  "giv.VCSLogView",
	IDName:     "vcs-log-view",
	Doc:        "VCSLogView is a view of the variables",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Log", &gti.Field{Name: "Log", Type: "vci.Log", Doc: "current log", Directives: gti.Directives{}}},
		{"File", &gti.Field{Name: "File", Type: "string", Doc: "file that this is a log of -- if blank then it is entire repository", Directives: gti.Directives{}}},
		{"Since", &gti.Field{Name: "Since", Type: "string", Doc: "date expression for how long ago to include log entries from", Directives: gti.Directives{}}},
		{"Repo", &gti.Field{Name: "Repo", Type: "vci.Repo", Doc: "version control system repository", Directives: gti.Directives{}}},
		{"RevA", &gti.Field{Name: "RevA", Type: "string", Doc: "revision A -- defaults to HEAD", Directives: gti.Directives{}}},
		{"RevB", &gti.Field{Name: "RevB", Type: "string", Doc: "revision B -- blank means current working copy", Directives: gti.Directives{}}},
		{"SetA", &gti.Field{Name: "SetA", Type: "bool", Doc: "double-click will set the A revision -- else B", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"gi.Layout", &gti.Field{Name: "gi.Layout", Type: "gi.Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &VCSLogView{},
})

// NewVCSLogView adds a new [VCSLogView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewVCSLogView(par ki.Ki, name ...string) *VCSLogView {
	return par.NewChild(VCSLogViewType, name...).(*VCSLogView)
}

// KiType returns the [*gti.Type] of [VCSLogView]
func (t *VCSLogView) KiType() *gti.Type {
	return VCSLogViewType
}

// New returns a new [*VCSLogView] value
func (t *VCSLogView) New() ki.Ki {
	return &VCSLogView{}
}
